// Code generated by go-grpc-imit-gen; DO NOT EDIT.
// github.com/n6o/go-grpc-imit-gen

package {{ .PkgName }}

import (
	sync "sync"
{{- range .Imports }}
    {{ .Alias }} {{ .Path }}
{{- end }}
)

{{- range .Interfaces }}
{{ $recvName := .RecvName }}
var _ {{ .Name }} = &{{ $recvName }}{}

type {{ $recvName }} struct {
	{{ .UnimplName }}

	// mocks
	mocks struct {
    {{- range .FuncSigs }}
        {{ .Name }} []func(
		{{- range $index, $param := .Params -}}
    		{{- if $index }},{{ end -}}
            {{- $param.Name }} {{ $param.Type -}}
		{{- end -}}
		) (
		{{- range $index, $result := .Results -}}
    		{{- if $index }},{{ end -}}
            {{- $result.Type -}}
		{{- end -}}
		)
    {{- end }}
	}

	// records
	records struct {
	{{- range .FuncSigs }}
        {{ .Name }} []struct {
		{{- range $index, $param := .Params }}
            {{ $param.Name }} {{ $param.Type }}
		{{- end }}
		}
    {{- end }}
	}

	// locks
	{{- range .FuncSigs }}
	lock{{ .Name }} sync.RWMutex
    {{- end }}
}

{{ range .FuncSigs }}
// {{ .Name }} Enqueue Mock
func (imit *{{ $recvName }}) Enqueue{{ .Name }}Mock(m func(
	{{- range $index, $param := .Params -}}
    	{{- if $index }},{{ end -}}
        {{- $param.Name }} {{ $param.Type -}}
	{{- end -}}
	) (
	{{- range $index, $result := .Results -}}
    	{{- if $index }},{{ end -}}
        {{- $result.Type -}}
	{{- end -}}
	)){
	imit.lock{{ .Name }}.Lock()
	imit.mocks.{{ .Name }} = append(imit.mocks.{{ .Name }}, m)
	imit.lock{{ .Name }}.Unlock()
}

// {{ .Name }} Enqueue Mocks
func (imit *{{ $recvName }}) Enqueue{{ .Name }}Mocks(ms []func(
	{{- range $index, $param := .Params -}}
    	{{- if $index }},{{ end -}}
        {{- $param.Name }} {{ $param.Type -}}
	{{- end -}}
	) (
	{{- range $index, $result := .Results -}}
    	{{- if $index }},{{ end -}}
        {{- $result.Type -}}
	{{- end -}}
	)){
	imit.lock{{ .Name }}.Lock()
	imit.mocks.{{ .Name }} = append(imit.mocks.{{ .Name }}, ms...)
	imit.lock{{ .Name }}.Unlock()
}

// {{ .Name }} Take Records
func (imit *{{ $recvName }}) Take{{ .Name }}Records() [] struct { {{ range $index, $param := .Params }}
    {{ $param.Name }} {{ $param.Type -}}
{{ end }}
} {
	var records []struct { {{ range $index, $param := .Params }}
        {{ $param.Name }} {{ $param.Type -}}
    {{ end }}
	}

	// clear records
	imit.lock{{ .Name }}.Lock()
	records = imit.records.{{ .Name }}
	imit.records.{{ .Name }} = nil
	imit.lock{{ .Name }}.Unlock()

    return records
}

// {{ .Name }} Imitation
func (imit *{{ $recvName }}) {{ .Name }}(
    {{- range $index, $param := .Params -}}
	    {{ if $index }},{{ end }}
        {{- $param.Name }} {{ $param.Type -}}
    {{- end -}}
) (
	{{- range $index, $result := .Results -}}
    	{{ if $index }},{{ end }}
        {{- $result.Type -}}
	{{- end -}}
) {
	if len(imit.mocks.{{ .Name }}) == 0 {
		panic("{{ $recvName }}.{{ .Name }} mocks is nil but {{ $recvName }}.{{ .Name }} was just called")
	}

	call := struct { {{ range $index, $param := .Params }}
	    {{ $param.Name }} {{ $param.Type -}}
    {{ end }}
	}{ {{ range $index, $param := .Params }}
		{{ $param.Name }}: {{ $param.Name -}}, {{ end }}
	}

	imit.lock{{ .Name }}.Lock()
	// record call
	imit.records.{{ .Name }} = append(imit.records.{{ .Name }}, call)
	// pop mock
	mockFunc := imit.mocks.{{ .Name }}[0]
	imit.mocks.{{ .Name }} = imit.mocks.{{ .Name }}[1:]
	imit.lock{{ .Name }}.Unlock()

	return mockFunc(
	{{- range $index, $param := .Params -}}
    	{{ if $index }}, {{ end }}
        {{- $param.Name -}}
	{{- end -}}
	)
}
{{ end }}

{{ end }}
