// Code generated by go-grpc-imit-gen; DO NOT EDIT.
// github.com/n6o/go-grpc-imit-gen

package imit_pubsub

import (
	context "context"
	sync "sync"

	pubsub "google.golang.org/genproto/googleapis/pubsub/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

var _ pubsub.PublisherServer = &ImitPublisherServer{}

type ImitPublisherServer struct {
	pubsub.UnimplementedPublisherServer

	// mocks
	mocks struct {
		CreateTopic            []func(P0 context.Context, P1 *pubsub.Topic) (*pubsub.Topic, error)
		DeleteTopic            []func(P0 context.Context, P1 *pubsub.DeleteTopicRequest) (*emptypb.Empty, error)
		DetachSubscription     []func(P0 context.Context, P1 *pubsub.DetachSubscriptionRequest) (*pubsub.DetachSubscriptionResponse, error)
		GetTopic               []func(P0 context.Context, P1 *pubsub.GetTopicRequest) (*pubsub.Topic, error)
		ListTopicSnapshots     []func(P0 context.Context, P1 *pubsub.ListTopicSnapshotsRequest) (*pubsub.ListTopicSnapshotsResponse, error)
		ListTopicSubscriptions []func(P0 context.Context, P1 *pubsub.ListTopicSubscriptionsRequest) (*pubsub.ListTopicSubscriptionsResponse, error)
		ListTopics             []func(P0 context.Context, P1 *pubsub.ListTopicsRequest) (*pubsub.ListTopicsResponse, error)
		Publish                []func(P0 context.Context, P1 *pubsub.PublishRequest) (*pubsub.PublishResponse, error)
		UpdateTopic            []func(P0 context.Context, P1 *pubsub.UpdateTopicRequest) (*pubsub.Topic, error)
	}

	// records
	records struct {
		CreateTopic []struct {
			P0 context.Context
			P1 *pubsub.Topic
		}
		DeleteTopic []struct {
			P0 context.Context
			P1 *pubsub.DeleteTopicRequest
		}
		DetachSubscription []struct {
			P0 context.Context
			P1 *pubsub.DetachSubscriptionRequest
		}
		GetTopic []struct {
			P0 context.Context
			P1 *pubsub.GetTopicRequest
		}
		ListTopicSnapshots []struct {
			P0 context.Context
			P1 *pubsub.ListTopicSnapshotsRequest
		}
		ListTopicSubscriptions []struct {
			P0 context.Context
			P1 *pubsub.ListTopicSubscriptionsRequest
		}
		ListTopics []struct {
			P0 context.Context
			P1 *pubsub.ListTopicsRequest
		}
		Publish []struct {
			P0 context.Context
			P1 *pubsub.PublishRequest
		}
		UpdateTopic []struct {
			P0 context.Context
			P1 *pubsub.UpdateTopicRequest
		}
	}

	// locks
	lockCreateTopic            sync.RWMutex
	lockDeleteTopic            sync.RWMutex
	lockDetachSubscription     sync.RWMutex
	lockGetTopic               sync.RWMutex
	lockListTopicSnapshots     sync.RWMutex
	lockListTopicSubscriptions sync.RWMutex
	lockListTopics             sync.RWMutex
	lockPublish                sync.RWMutex
	lockUpdateTopic            sync.RWMutex
}

// CreateTopic Enqueue Mock
func (imit *ImitPublisherServer) EnqueueCreateTopicMock(m func(P0 context.Context, P1 *pubsub.Topic) (*pubsub.Topic, error)) {
	imit.lockCreateTopic.Lock()
	imit.mocks.CreateTopic = append(imit.mocks.CreateTopic, m)
	imit.lockCreateTopic.Unlock()
}

// CreateTopic Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueCreateTopicMocks(ms []func(P0 context.Context, P1 *pubsub.Topic) (*pubsub.Topic, error)) {
	imit.lockCreateTopic.Lock()
	imit.mocks.CreateTopic = append(imit.mocks.CreateTopic, ms...)
	imit.lockCreateTopic.Unlock()
}

// CreateTopic Take Records
func (imit *ImitPublisherServer) TakeCreateTopicRecords() []struct {
	P0 context.Context
	P1 *pubsub.Topic
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.Topic
	}

	// clear records
	imit.lockCreateTopic.Lock()
	records = imit.records.CreateTopic
	imit.records.CreateTopic = nil
	imit.lockCreateTopic.Unlock()

	return records
}

// CreateTopic Imitation
func (imit *ImitPublisherServer) CreateTopic(P0 context.Context, P1 *pubsub.Topic) (*pubsub.Topic, error) {
	if len(imit.mocks.CreateTopic) == 0 {
		panic("ImitPublisherServer.CreateTopic mocks is nil but ImitPublisherServer.CreateTopic was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.Topic
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockCreateTopic.Lock()
	// record call
	imit.records.CreateTopic = append(imit.records.CreateTopic, call)
	// pop mock
	mockFunc := imit.mocks.CreateTopic[0]
	imit.mocks.CreateTopic = imit.mocks.CreateTopic[1:]
	imit.lockCreateTopic.Unlock()

	return mockFunc(P0, P1)
}

// DeleteTopic Enqueue Mock
func (imit *ImitPublisherServer) EnqueueDeleteTopicMock(m func(P0 context.Context, P1 *pubsub.DeleteTopicRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteTopic.Lock()
	imit.mocks.DeleteTopic = append(imit.mocks.DeleteTopic, m)
	imit.lockDeleteTopic.Unlock()
}

// DeleteTopic Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueDeleteTopicMocks(ms []func(P0 context.Context, P1 *pubsub.DeleteTopicRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteTopic.Lock()
	imit.mocks.DeleteTopic = append(imit.mocks.DeleteTopic, ms...)
	imit.lockDeleteTopic.Unlock()
}

// DeleteTopic Take Records
func (imit *ImitPublisherServer) TakeDeleteTopicRecords() []struct {
	P0 context.Context
	P1 *pubsub.DeleteTopicRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.DeleteTopicRequest
	}

	// clear records
	imit.lockDeleteTopic.Lock()
	records = imit.records.DeleteTopic
	imit.records.DeleteTopic = nil
	imit.lockDeleteTopic.Unlock()

	return records
}

// DeleteTopic Imitation
func (imit *ImitPublisherServer) DeleteTopic(P0 context.Context, P1 *pubsub.DeleteTopicRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.DeleteTopic) == 0 {
		panic("ImitPublisherServer.DeleteTopic mocks is nil but ImitPublisherServer.DeleteTopic was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.DeleteTopicRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockDeleteTopic.Lock()
	// record call
	imit.records.DeleteTopic = append(imit.records.DeleteTopic, call)
	// pop mock
	mockFunc := imit.mocks.DeleteTopic[0]
	imit.mocks.DeleteTopic = imit.mocks.DeleteTopic[1:]
	imit.lockDeleteTopic.Unlock()

	return mockFunc(P0, P1)
}

// DetachSubscription Enqueue Mock
func (imit *ImitPublisherServer) EnqueueDetachSubscriptionMock(m func(P0 context.Context, P1 *pubsub.DetachSubscriptionRequest) (*pubsub.DetachSubscriptionResponse, error)) {
	imit.lockDetachSubscription.Lock()
	imit.mocks.DetachSubscription = append(imit.mocks.DetachSubscription, m)
	imit.lockDetachSubscription.Unlock()
}

// DetachSubscription Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueDetachSubscriptionMocks(ms []func(P0 context.Context, P1 *pubsub.DetachSubscriptionRequest) (*pubsub.DetachSubscriptionResponse, error)) {
	imit.lockDetachSubscription.Lock()
	imit.mocks.DetachSubscription = append(imit.mocks.DetachSubscription, ms...)
	imit.lockDetachSubscription.Unlock()
}

// DetachSubscription Take Records
func (imit *ImitPublisherServer) TakeDetachSubscriptionRecords() []struct {
	P0 context.Context
	P1 *pubsub.DetachSubscriptionRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.DetachSubscriptionRequest
	}

	// clear records
	imit.lockDetachSubscription.Lock()
	records = imit.records.DetachSubscription
	imit.records.DetachSubscription = nil
	imit.lockDetachSubscription.Unlock()

	return records
}

// DetachSubscription Imitation
func (imit *ImitPublisherServer) DetachSubscription(P0 context.Context, P1 *pubsub.DetachSubscriptionRequest) (*pubsub.DetachSubscriptionResponse, error) {
	if len(imit.mocks.DetachSubscription) == 0 {
		panic("ImitPublisherServer.DetachSubscription mocks is nil but ImitPublisherServer.DetachSubscription was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.DetachSubscriptionRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockDetachSubscription.Lock()
	// record call
	imit.records.DetachSubscription = append(imit.records.DetachSubscription, call)
	// pop mock
	mockFunc := imit.mocks.DetachSubscription[0]
	imit.mocks.DetachSubscription = imit.mocks.DetachSubscription[1:]
	imit.lockDetachSubscription.Unlock()

	return mockFunc(P0, P1)
}

// GetTopic Enqueue Mock
func (imit *ImitPublisherServer) EnqueueGetTopicMock(m func(P0 context.Context, P1 *pubsub.GetTopicRequest) (*pubsub.Topic, error)) {
	imit.lockGetTopic.Lock()
	imit.mocks.GetTopic = append(imit.mocks.GetTopic, m)
	imit.lockGetTopic.Unlock()
}

// GetTopic Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueGetTopicMocks(ms []func(P0 context.Context, P1 *pubsub.GetTopicRequest) (*pubsub.Topic, error)) {
	imit.lockGetTopic.Lock()
	imit.mocks.GetTopic = append(imit.mocks.GetTopic, ms...)
	imit.lockGetTopic.Unlock()
}

// GetTopic Take Records
func (imit *ImitPublisherServer) TakeGetTopicRecords() []struct {
	P0 context.Context
	P1 *pubsub.GetTopicRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.GetTopicRequest
	}

	// clear records
	imit.lockGetTopic.Lock()
	records = imit.records.GetTopic
	imit.records.GetTopic = nil
	imit.lockGetTopic.Unlock()

	return records
}

// GetTopic Imitation
func (imit *ImitPublisherServer) GetTopic(P0 context.Context, P1 *pubsub.GetTopicRequest) (*pubsub.Topic, error) {
	if len(imit.mocks.GetTopic) == 0 {
		panic("ImitPublisherServer.GetTopic mocks is nil but ImitPublisherServer.GetTopic was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.GetTopicRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockGetTopic.Lock()
	// record call
	imit.records.GetTopic = append(imit.records.GetTopic, call)
	// pop mock
	mockFunc := imit.mocks.GetTopic[0]
	imit.mocks.GetTopic = imit.mocks.GetTopic[1:]
	imit.lockGetTopic.Unlock()

	return mockFunc(P0, P1)
}

// ListTopicSnapshots Enqueue Mock
func (imit *ImitPublisherServer) EnqueueListTopicSnapshotsMock(m func(P0 context.Context, P1 *pubsub.ListTopicSnapshotsRequest) (*pubsub.ListTopicSnapshotsResponse, error)) {
	imit.lockListTopicSnapshots.Lock()
	imit.mocks.ListTopicSnapshots = append(imit.mocks.ListTopicSnapshots, m)
	imit.lockListTopicSnapshots.Unlock()
}

// ListTopicSnapshots Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueListTopicSnapshotsMocks(ms []func(P0 context.Context, P1 *pubsub.ListTopicSnapshotsRequest) (*pubsub.ListTopicSnapshotsResponse, error)) {
	imit.lockListTopicSnapshots.Lock()
	imit.mocks.ListTopicSnapshots = append(imit.mocks.ListTopicSnapshots, ms...)
	imit.lockListTopicSnapshots.Unlock()
}

// ListTopicSnapshots Take Records
func (imit *ImitPublisherServer) TakeListTopicSnapshotsRecords() []struct {
	P0 context.Context
	P1 *pubsub.ListTopicSnapshotsRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ListTopicSnapshotsRequest
	}

	// clear records
	imit.lockListTopicSnapshots.Lock()
	records = imit.records.ListTopicSnapshots
	imit.records.ListTopicSnapshots = nil
	imit.lockListTopicSnapshots.Unlock()

	return records
}

// ListTopicSnapshots Imitation
func (imit *ImitPublisherServer) ListTopicSnapshots(P0 context.Context, P1 *pubsub.ListTopicSnapshotsRequest) (*pubsub.ListTopicSnapshotsResponse, error) {
	if len(imit.mocks.ListTopicSnapshots) == 0 {
		panic("ImitPublisherServer.ListTopicSnapshots mocks is nil but ImitPublisherServer.ListTopicSnapshots was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ListTopicSnapshotsRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListTopicSnapshots.Lock()
	// record call
	imit.records.ListTopicSnapshots = append(imit.records.ListTopicSnapshots, call)
	// pop mock
	mockFunc := imit.mocks.ListTopicSnapshots[0]
	imit.mocks.ListTopicSnapshots = imit.mocks.ListTopicSnapshots[1:]
	imit.lockListTopicSnapshots.Unlock()

	return mockFunc(P0, P1)
}

// ListTopicSubscriptions Enqueue Mock
func (imit *ImitPublisherServer) EnqueueListTopicSubscriptionsMock(m func(P0 context.Context, P1 *pubsub.ListTopicSubscriptionsRequest) (*pubsub.ListTopicSubscriptionsResponse, error)) {
	imit.lockListTopicSubscriptions.Lock()
	imit.mocks.ListTopicSubscriptions = append(imit.mocks.ListTopicSubscriptions, m)
	imit.lockListTopicSubscriptions.Unlock()
}

// ListTopicSubscriptions Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueListTopicSubscriptionsMocks(ms []func(P0 context.Context, P1 *pubsub.ListTopicSubscriptionsRequest) (*pubsub.ListTopicSubscriptionsResponse, error)) {
	imit.lockListTopicSubscriptions.Lock()
	imit.mocks.ListTopicSubscriptions = append(imit.mocks.ListTopicSubscriptions, ms...)
	imit.lockListTopicSubscriptions.Unlock()
}

// ListTopicSubscriptions Take Records
func (imit *ImitPublisherServer) TakeListTopicSubscriptionsRecords() []struct {
	P0 context.Context
	P1 *pubsub.ListTopicSubscriptionsRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ListTopicSubscriptionsRequest
	}

	// clear records
	imit.lockListTopicSubscriptions.Lock()
	records = imit.records.ListTopicSubscriptions
	imit.records.ListTopicSubscriptions = nil
	imit.lockListTopicSubscriptions.Unlock()

	return records
}

// ListTopicSubscriptions Imitation
func (imit *ImitPublisherServer) ListTopicSubscriptions(P0 context.Context, P1 *pubsub.ListTopicSubscriptionsRequest) (*pubsub.ListTopicSubscriptionsResponse, error) {
	if len(imit.mocks.ListTopicSubscriptions) == 0 {
		panic("ImitPublisherServer.ListTopicSubscriptions mocks is nil but ImitPublisherServer.ListTopicSubscriptions was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ListTopicSubscriptionsRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListTopicSubscriptions.Lock()
	// record call
	imit.records.ListTopicSubscriptions = append(imit.records.ListTopicSubscriptions, call)
	// pop mock
	mockFunc := imit.mocks.ListTopicSubscriptions[0]
	imit.mocks.ListTopicSubscriptions = imit.mocks.ListTopicSubscriptions[1:]
	imit.lockListTopicSubscriptions.Unlock()

	return mockFunc(P0, P1)
}

// ListTopics Enqueue Mock
func (imit *ImitPublisherServer) EnqueueListTopicsMock(m func(P0 context.Context, P1 *pubsub.ListTopicsRequest) (*pubsub.ListTopicsResponse, error)) {
	imit.lockListTopics.Lock()
	imit.mocks.ListTopics = append(imit.mocks.ListTopics, m)
	imit.lockListTopics.Unlock()
}

// ListTopics Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueListTopicsMocks(ms []func(P0 context.Context, P1 *pubsub.ListTopicsRequest) (*pubsub.ListTopicsResponse, error)) {
	imit.lockListTopics.Lock()
	imit.mocks.ListTopics = append(imit.mocks.ListTopics, ms...)
	imit.lockListTopics.Unlock()
}

// ListTopics Take Records
func (imit *ImitPublisherServer) TakeListTopicsRecords() []struct {
	P0 context.Context
	P1 *pubsub.ListTopicsRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ListTopicsRequest
	}

	// clear records
	imit.lockListTopics.Lock()
	records = imit.records.ListTopics
	imit.records.ListTopics = nil
	imit.lockListTopics.Unlock()

	return records
}

// ListTopics Imitation
func (imit *ImitPublisherServer) ListTopics(P0 context.Context, P1 *pubsub.ListTopicsRequest) (*pubsub.ListTopicsResponse, error) {
	if len(imit.mocks.ListTopics) == 0 {
		panic("ImitPublisherServer.ListTopics mocks is nil but ImitPublisherServer.ListTopics was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ListTopicsRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListTopics.Lock()
	// record call
	imit.records.ListTopics = append(imit.records.ListTopics, call)
	// pop mock
	mockFunc := imit.mocks.ListTopics[0]
	imit.mocks.ListTopics = imit.mocks.ListTopics[1:]
	imit.lockListTopics.Unlock()

	return mockFunc(P0, P1)
}

// Publish Enqueue Mock
func (imit *ImitPublisherServer) EnqueuePublishMock(m func(P0 context.Context, P1 *pubsub.PublishRequest) (*pubsub.PublishResponse, error)) {
	imit.lockPublish.Lock()
	imit.mocks.Publish = append(imit.mocks.Publish, m)
	imit.lockPublish.Unlock()
}

// Publish Enqueue Mocks
func (imit *ImitPublisherServer) EnqueuePublishMocks(ms []func(P0 context.Context, P1 *pubsub.PublishRequest) (*pubsub.PublishResponse, error)) {
	imit.lockPublish.Lock()
	imit.mocks.Publish = append(imit.mocks.Publish, ms...)
	imit.lockPublish.Unlock()
}

// Publish Take Records
func (imit *ImitPublisherServer) TakePublishRecords() []struct {
	P0 context.Context
	P1 *pubsub.PublishRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.PublishRequest
	}

	// clear records
	imit.lockPublish.Lock()
	records = imit.records.Publish
	imit.records.Publish = nil
	imit.lockPublish.Unlock()

	return records
}

// Publish Imitation
func (imit *ImitPublisherServer) Publish(P0 context.Context, P1 *pubsub.PublishRequest) (*pubsub.PublishResponse, error) {
	if len(imit.mocks.Publish) == 0 {
		panic("ImitPublisherServer.Publish mocks is nil but ImitPublisherServer.Publish was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.PublishRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockPublish.Lock()
	// record call
	imit.records.Publish = append(imit.records.Publish, call)
	// pop mock
	mockFunc := imit.mocks.Publish[0]
	imit.mocks.Publish = imit.mocks.Publish[1:]
	imit.lockPublish.Unlock()

	return mockFunc(P0, P1)
}

// UpdateTopic Enqueue Mock
func (imit *ImitPublisherServer) EnqueueUpdateTopicMock(m func(P0 context.Context, P1 *pubsub.UpdateTopicRequest) (*pubsub.Topic, error)) {
	imit.lockUpdateTopic.Lock()
	imit.mocks.UpdateTopic = append(imit.mocks.UpdateTopic, m)
	imit.lockUpdateTopic.Unlock()
}

// UpdateTopic Enqueue Mocks
func (imit *ImitPublisherServer) EnqueueUpdateTopicMocks(ms []func(P0 context.Context, P1 *pubsub.UpdateTopicRequest) (*pubsub.Topic, error)) {
	imit.lockUpdateTopic.Lock()
	imit.mocks.UpdateTopic = append(imit.mocks.UpdateTopic, ms...)
	imit.lockUpdateTopic.Unlock()
}

// UpdateTopic Take Records
func (imit *ImitPublisherServer) TakeUpdateTopicRecords() []struct {
	P0 context.Context
	P1 *pubsub.UpdateTopicRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.UpdateTopicRequest
	}

	// clear records
	imit.lockUpdateTopic.Lock()
	records = imit.records.UpdateTopic
	imit.records.UpdateTopic = nil
	imit.lockUpdateTopic.Unlock()

	return records
}

// UpdateTopic Imitation
func (imit *ImitPublisherServer) UpdateTopic(P0 context.Context, P1 *pubsub.UpdateTopicRequest) (*pubsub.Topic, error) {
	if len(imit.mocks.UpdateTopic) == 0 {
		panic("ImitPublisherServer.UpdateTopic mocks is nil but ImitPublisherServer.UpdateTopic was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.UpdateTopicRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockUpdateTopic.Lock()
	// record call
	imit.records.UpdateTopic = append(imit.records.UpdateTopic, call)
	// pop mock
	mockFunc := imit.mocks.UpdateTopic[0]
	imit.mocks.UpdateTopic = imit.mocks.UpdateTopic[1:]
	imit.lockUpdateTopic.Unlock()

	return mockFunc(P0, P1)
}

var _ pubsub.SchemaServiceServer = &ImitSchemaServiceServer{}

type ImitSchemaServiceServer struct {
	pubsub.UnimplementedSchemaServiceServer

	// mocks
	mocks struct {
		CreateSchema    []func(P0 context.Context, P1 *pubsub.CreateSchemaRequest) (*pubsub.Schema, error)
		DeleteSchema    []func(P0 context.Context, P1 *pubsub.DeleteSchemaRequest) (*emptypb.Empty, error)
		GetSchema       []func(P0 context.Context, P1 *pubsub.GetSchemaRequest) (*pubsub.Schema, error)
		ListSchemas     []func(P0 context.Context, P1 *pubsub.ListSchemasRequest) (*pubsub.ListSchemasResponse, error)
		ValidateMessage []func(P0 context.Context, P1 *pubsub.ValidateMessageRequest) (*pubsub.ValidateMessageResponse, error)
		ValidateSchema  []func(P0 context.Context, P1 *pubsub.ValidateSchemaRequest) (*pubsub.ValidateSchemaResponse, error)
	}

	// records
	records struct {
		CreateSchema []struct {
			P0 context.Context
			P1 *pubsub.CreateSchemaRequest
		}
		DeleteSchema []struct {
			P0 context.Context
			P1 *pubsub.DeleteSchemaRequest
		}
		GetSchema []struct {
			P0 context.Context
			P1 *pubsub.GetSchemaRequest
		}
		ListSchemas []struct {
			P0 context.Context
			P1 *pubsub.ListSchemasRequest
		}
		ValidateMessage []struct {
			P0 context.Context
			P1 *pubsub.ValidateMessageRequest
		}
		ValidateSchema []struct {
			P0 context.Context
			P1 *pubsub.ValidateSchemaRequest
		}
	}

	// locks
	lockCreateSchema    sync.RWMutex
	lockDeleteSchema    sync.RWMutex
	lockGetSchema       sync.RWMutex
	lockListSchemas     sync.RWMutex
	lockValidateMessage sync.RWMutex
	lockValidateSchema  sync.RWMutex
}

// CreateSchema Enqueue Mock
func (imit *ImitSchemaServiceServer) EnqueueCreateSchemaMock(m func(P0 context.Context, P1 *pubsub.CreateSchemaRequest) (*pubsub.Schema, error)) {
	imit.lockCreateSchema.Lock()
	imit.mocks.CreateSchema = append(imit.mocks.CreateSchema, m)
	imit.lockCreateSchema.Unlock()
}

// CreateSchema Enqueue Mocks
func (imit *ImitSchemaServiceServer) EnqueueCreateSchemaMocks(ms []func(P0 context.Context, P1 *pubsub.CreateSchemaRequest) (*pubsub.Schema, error)) {
	imit.lockCreateSchema.Lock()
	imit.mocks.CreateSchema = append(imit.mocks.CreateSchema, ms...)
	imit.lockCreateSchema.Unlock()
}

// CreateSchema Take Records
func (imit *ImitSchemaServiceServer) TakeCreateSchemaRecords() []struct {
	P0 context.Context
	P1 *pubsub.CreateSchemaRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.CreateSchemaRequest
	}

	// clear records
	imit.lockCreateSchema.Lock()
	records = imit.records.CreateSchema
	imit.records.CreateSchema = nil
	imit.lockCreateSchema.Unlock()

	return records
}

// CreateSchema Imitation
func (imit *ImitSchemaServiceServer) CreateSchema(P0 context.Context, P1 *pubsub.CreateSchemaRequest) (*pubsub.Schema, error) {
	if len(imit.mocks.CreateSchema) == 0 {
		panic("ImitSchemaServiceServer.CreateSchema mocks is nil but ImitSchemaServiceServer.CreateSchema was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.CreateSchemaRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockCreateSchema.Lock()
	// record call
	imit.records.CreateSchema = append(imit.records.CreateSchema, call)
	// pop mock
	mockFunc := imit.mocks.CreateSchema[0]
	imit.mocks.CreateSchema = imit.mocks.CreateSchema[1:]
	imit.lockCreateSchema.Unlock()

	return mockFunc(P0, P1)
}

// DeleteSchema Enqueue Mock
func (imit *ImitSchemaServiceServer) EnqueueDeleteSchemaMock(m func(P0 context.Context, P1 *pubsub.DeleteSchemaRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteSchema.Lock()
	imit.mocks.DeleteSchema = append(imit.mocks.DeleteSchema, m)
	imit.lockDeleteSchema.Unlock()
}

// DeleteSchema Enqueue Mocks
func (imit *ImitSchemaServiceServer) EnqueueDeleteSchemaMocks(ms []func(P0 context.Context, P1 *pubsub.DeleteSchemaRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteSchema.Lock()
	imit.mocks.DeleteSchema = append(imit.mocks.DeleteSchema, ms...)
	imit.lockDeleteSchema.Unlock()
}

// DeleteSchema Take Records
func (imit *ImitSchemaServiceServer) TakeDeleteSchemaRecords() []struct {
	P0 context.Context
	P1 *pubsub.DeleteSchemaRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.DeleteSchemaRequest
	}

	// clear records
	imit.lockDeleteSchema.Lock()
	records = imit.records.DeleteSchema
	imit.records.DeleteSchema = nil
	imit.lockDeleteSchema.Unlock()

	return records
}

// DeleteSchema Imitation
func (imit *ImitSchemaServiceServer) DeleteSchema(P0 context.Context, P1 *pubsub.DeleteSchemaRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.DeleteSchema) == 0 {
		panic("ImitSchemaServiceServer.DeleteSchema mocks is nil but ImitSchemaServiceServer.DeleteSchema was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.DeleteSchemaRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockDeleteSchema.Lock()
	// record call
	imit.records.DeleteSchema = append(imit.records.DeleteSchema, call)
	// pop mock
	mockFunc := imit.mocks.DeleteSchema[0]
	imit.mocks.DeleteSchema = imit.mocks.DeleteSchema[1:]
	imit.lockDeleteSchema.Unlock()

	return mockFunc(P0, P1)
}

// GetSchema Enqueue Mock
func (imit *ImitSchemaServiceServer) EnqueueGetSchemaMock(m func(P0 context.Context, P1 *pubsub.GetSchemaRequest) (*pubsub.Schema, error)) {
	imit.lockGetSchema.Lock()
	imit.mocks.GetSchema = append(imit.mocks.GetSchema, m)
	imit.lockGetSchema.Unlock()
}

// GetSchema Enqueue Mocks
func (imit *ImitSchemaServiceServer) EnqueueGetSchemaMocks(ms []func(P0 context.Context, P1 *pubsub.GetSchemaRequest) (*pubsub.Schema, error)) {
	imit.lockGetSchema.Lock()
	imit.mocks.GetSchema = append(imit.mocks.GetSchema, ms...)
	imit.lockGetSchema.Unlock()
}

// GetSchema Take Records
func (imit *ImitSchemaServiceServer) TakeGetSchemaRecords() []struct {
	P0 context.Context
	P1 *pubsub.GetSchemaRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.GetSchemaRequest
	}

	// clear records
	imit.lockGetSchema.Lock()
	records = imit.records.GetSchema
	imit.records.GetSchema = nil
	imit.lockGetSchema.Unlock()

	return records
}

// GetSchema Imitation
func (imit *ImitSchemaServiceServer) GetSchema(P0 context.Context, P1 *pubsub.GetSchemaRequest) (*pubsub.Schema, error) {
	if len(imit.mocks.GetSchema) == 0 {
		panic("ImitSchemaServiceServer.GetSchema mocks is nil but ImitSchemaServiceServer.GetSchema was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.GetSchemaRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockGetSchema.Lock()
	// record call
	imit.records.GetSchema = append(imit.records.GetSchema, call)
	// pop mock
	mockFunc := imit.mocks.GetSchema[0]
	imit.mocks.GetSchema = imit.mocks.GetSchema[1:]
	imit.lockGetSchema.Unlock()

	return mockFunc(P0, P1)
}

// ListSchemas Enqueue Mock
func (imit *ImitSchemaServiceServer) EnqueueListSchemasMock(m func(P0 context.Context, P1 *pubsub.ListSchemasRequest) (*pubsub.ListSchemasResponse, error)) {
	imit.lockListSchemas.Lock()
	imit.mocks.ListSchemas = append(imit.mocks.ListSchemas, m)
	imit.lockListSchemas.Unlock()
}

// ListSchemas Enqueue Mocks
func (imit *ImitSchemaServiceServer) EnqueueListSchemasMocks(ms []func(P0 context.Context, P1 *pubsub.ListSchemasRequest) (*pubsub.ListSchemasResponse, error)) {
	imit.lockListSchemas.Lock()
	imit.mocks.ListSchemas = append(imit.mocks.ListSchemas, ms...)
	imit.lockListSchemas.Unlock()
}

// ListSchemas Take Records
func (imit *ImitSchemaServiceServer) TakeListSchemasRecords() []struct {
	P0 context.Context
	P1 *pubsub.ListSchemasRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ListSchemasRequest
	}

	// clear records
	imit.lockListSchemas.Lock()
	records = imit.records.ListSchemas
	imit.records.ListSchemas = nil
	imit.lockListSchemas.Unlock()

	return records
}

// ListSchemas Imitation
func (imit *ImitSchemaServiceServer) ListSchemas(P0 context.Context, P1 *pubsub.ListSchemasRequest) (*pubsub.ListSchemasResponse, error) {
	if len(imit.mocks.ListSchemas) == 0 {
		panic("ImitSchemaServiceServer.ListSchemas mocks is nil but ImitSchemaServiceServer.ListSchemas was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ListSchemasRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListSchemas.Lock()
	// record call
	imit.records.ListSchemas = append(imit.records.ListSchemas, call)
	// pop mock
	mockFunc := imit.mocks.ListSchemas[0]
	imit.mocks.ListSchemas = imit.mocks.ListSchemas[1:]
	imit.lockListSchemas.Unlock()

	return mockFunc(P0, P1)
}

// ValidateMessage Enqueue Mock
func (imit *ImitSchemaServiceServer) EnqueueValidateMessageMock(m func(P0 context.Context, P1 *pubsub.ValidateMessageRequest) (*pubsub.ValidateMessageResponse, error)) {
	imit.lockValidateMessage.Lock()
	imit.mocks.ValidateMessage = append(imit.mocks.ValidateMessage, m)
	imit.lockValidateMessage.Unlock()
}

// ValidateMessage Enqueue Mocks
func (imit *ImitSchemaServiceServer) EnqueueValidateMessageMocks(ms []func(P0 context.Context, P1 *pubsub.ValidateMessageRequest) (*pubsub.ValidateMessageResponse, error)) {
	imit.lockValidateMessage.Lock()
	imit.mocks.ValidateMessage = append(imit.mocks.ValidateMessage, ms...)
	imit.lockValidateMessage.Unlock()
}

// ValidateMessage Take Records
func (imit *ImitSchemaServiceServer) TakeValidateMessageRecords() []struct {
	P0 context.Context
	P1 *pubsub.ValidateMessageRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ValidateMessageRequest
	}

	// clear records
	imit.lockValidateMessage.Lock()
	records = imit.records.ValidateMessage
	imit.records.ValidateMessage = nil
	imit.lockValidateMessage.Unlock()

	return records
}

// ValidateMessage Imitation
func (imit *ImitSchemaServiceServer) ValidateMessage(P0 context.Context, P1 *pubsub.ValidateMessageRequest) (*pubsub.ValidateMessageResponse, error) {
	if len(imit.mocks.ValidateMessage) == 0 {
		panic("ImitSchemaServiceServer.ValidateMessage mocks is nil but ImitSchemaServiceServer.ValidateMessage was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ValidateMessageRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockValidateMessage.Lock()
	// record call
	imit.records.ValidateMessage = append(imit.records.ValidateMessage, call)
	// pop mock
	mockFunc := imit.mocks.ValidateMessage[0]
	imit.mocks.ValidateMessage = imit.mocks.ValidateMessage[1:]
	imit.lockValidateMessage.Unlock()

	return mockFunc(P0, P1)
}

// ValidateSchema Enqueue Mock
func (imit *ImitSchemaServiceServer) EnqueueValidateSchemaMock(m func(P0 context.Context, P1 *pubsub.ValidateSchemaRequest) (*pubsub.ValidateSchemaResponse, error)) {
	imit.lockValidateSchema.Lock()
	imit.mocks.ValidateSchema = append(imit.mocks.ValidateSchema, m)
	imit.lockValidateSchema.Unlock()
}

// ValidateSchema Enqueue Mocks
func (imit *ImitSchemaServiceServer) EnqueueValidateSchemaMocks(ms []func(P0 context.Context, P1 *pubsub.ValidateSchemaRequest) (*pubsub.ValidateSchemaResponse, error)) {
	imit.lockValidateSchema.Lock()
	imit.mocks.ValidateSchema = append(imit.mocks.ValidateSchema, ms...)
	imit.lockValidateSchema.Unlock()
}

// ValidateSchema Take Records
func (imit *ImitSchemaServiceServer) TakeValidateSchemaRecords() []struct {
	P0 context.Context
	P1 *pubsub.ValidateSchemaRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ValidateSchemaRequest
	}

	// clear records
	imit.lockValidateSchema.Lock()
	records = imit.records.ValidateSchema
	imit.records.ValidateSchema = nil
	imit.lockValidateSchema.Unlock()

	return records
}

// ValidateSchema Imitation
func (imit *ImitSchemaServiceServer) ValidateSchema(P0 context.Context, P1 *pubsub.ValidateSchemaRequest) (*pubsub.ValidateSchemaResponse, error) {
	if len(imit.mocks.ValidateSchema) == 0 {
		panic("ImitSchemaServiceServer.ValidateSchema mocks is nil but ImitSchemaServiceServer.ValidateSchema was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ValidateSchemaRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockValidateSchema.Lock()
	// record call
	imit.records.ValidateSchema = append(imit.records.ValidateSchema, call)
	// pop mock
	mockFunc := imit.mocks.ValidateSchema[0]
	imit.mocks.ValidateSchema = imit.mocks.ValidateSchema[1:]
	imit.lockValidateSchema.Unlock()

	return mockFunc(P0, P1)
}

var _ pubsub.SubscriberServer = &ImitSubscriberServer{}

type ImitSubscriberServer struct {
	pubsub.UnimplementedSubscriberServer

	// mocks
	mocks struct {
		Acknowledge        []func(P0 context.Context, P1 *pubsub.AcknowledgeRequest) (*emptypb.Empty, error)
		CreateSnapshot     []func(P0 context.Context, P1 *pubsub.CreateSnapshotRequest) (*pubsub.Snapshot, error)
		CreateSubscription []func(P0 context.Context, P1 *pubsub.Subscription) (*pubsub.Subscription, error)
		DeleteSnapshot     []func(P0 context.Context, P1 *pubsub.DeleteSnapshotRequest) (*emptypb.Empty, error)
		DeleteSubscription []func(P0 context.Context, P1 *pubsub.DeleteSubscriptionRequest) (*emptypb.Empty, error)
		GetSnapshot        []func(P0 context.Context, P1 *pubsub.GetSnapshotRequest) (*pubsub.Snapshot, error)
		GetSubscription    []func(P0 context.Context, P1 *pubsub.GetSubscriptionRequest) (*pubsub.Subscription, error)
		ListSnapshots      []func(P0 context.Context, P1 *pubsub.ListSnapshotsRequest) (*pubsub.ListSnapshotsResponse, error)
		ListSubscriptions  []func(P0 context.Context, P1 *pubsub.ListSubscriptionsRequest) (*pubsub.ListSubscriptionsResponse, error)
		ModifyAckDeadline  []func(P0 context.Context, P1 *pubsub.ModifyAckDeadlineRequest) (*emptypb.Empty, error)
		ModifyPushConfig   []func(P0 context.Context, P1 *pubsub.ModifyPushConfigRequest) (*emptypb.Empty, error)
		Pull               []func(P0 context.Context, P1 *pubsub.PullRequest) (*pubsub.PullResponse, error)
		Seek               []func(P0 context.Context, P1 *pubsub.SeekRequest) (*pubsub.SeekResponse, error)
		StreamingPull      []func(P0 pubsub.Subscriber_StreamingPullServer) error
		UpdateSnapshot     []func(P0 context.Context, P1 *pubsub.UpdateSnapshotRequest) (*pubsub.Snapshot, error)
		UpdateSubscription []func(P0 context.Context, P1 *pubsub.UpdateSubscriptionRequest) (*pubsub.Subscription, error)
	}

	// records
	records struct {
		Acknowledge []struct {
			P0 context.Context
			P1 *pubsub.AcknowledgeRequest
		}
		CreateSnapshot []struct {
			P0 context.Context
			P1 *pubsub.CreateSnapshotRequest
		}
		CreateSubscription []struct {
			P0 context.Context
			P1 *pubsub.Subscription
		}
		DeleteSnapshot []struct {
			P0 context.Context
			P1 *pubsub.DeleteSnapshotRequest
		}
		DeleteSubscription []struct {
			P0 context.Context
			P1 *pubsub.DeleteSubscriptionRequest
		}
		GetSnapshot []struct {
			P0 context.Context
			P1 *pubsub.GetSnapshotRequest
		}
		GetSubscription []struct {
			P0 context.Context
			P1 *pubsub.GetSubscriptionRequest
		}
		ListSnapshots []struct {
			P0 context.Context
			P1 *pubsub.ListSnapshotsRequest
		}
		ListSubscriptions []struct {
			P0 context.Context
			P1 *pubsub.ListSubscriptionsRequest
		}
		ModifyAckDeadline []struct {
			P0 context.Context
			P1 *pubsub.ModifyAckDeadlineRequest
		}
		ModifyPushConfig []struct {
			P0 context.Context
			P1 *pubsub.ModifyPushConfigRequest
		}
		Pull []struct {
			P0 context.Context
			P1 *pubsub.PullRequest
		}
		Seek []struct {
			P0 context.Context
			P1 *pubsub.SeekRequest
		}
		StreamingPull []struct {
			P0 pubsub.Subscriber_StreamingPullServer
		}
		UpdateSnapshot []struct {
			P0 context.Context
			P1 *pubsub.UpdateSnapshotRequest
		}
		UpdateSubscription []struct {
			P0 context.Context
			P1 *pubsub.UpdateSubscriptionRequest
		}
	}

	// locks
	lockAcknowledge        sync.RWMutex
	lockCreateSnapshot     sync.RWMutex
	lockCreateSubscription sync.RWMutex
	lockDeleteSnapshot     sync.RWMutex
	lockDeleteSubscription sync.RWMutex
	lockGetSnapshot        sync.RWMutex
	lockGetSubscription    sync.RWMutex
	lockListSnapshots      sync.RWMutex
	lockListSubscriptions  sync.RWMutex
	lockModifyAckDeadline  sync.RWMutex
	lockModifyPushConfig   sync.RWMutex
	lockPull               sync.RWMutex
	lockSeek               sync.RWMutex
	lockStreamingPull      sync.RWMutex
	lockUpdateSnapshot     sync.RWMutex
	lockUpdateSubscription sync.RWMutex
}

// Acknowledge Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueAcknowledgeMock(m func(P0 context.Context, P1 *pubsub.AcknowledgeRequest) (*emptypb.Empty, error)) {
	imit.lockAcknowledge.Lock()
	imit.mocks.Acknowledge = append(imit.mocks.Acknowledge, m)
	imit.lockAcknowledge.Unlock()
}

// Acknowledge Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueAcknowledgeMocks(ms []func(P0 context.Context, P1 *pubsub.AcknowledgeRequest) (*emptypb.Empty, error)) {
	imit.lockAcknowledge.Lock()
	imit.mocks.Acknowledge = append(imit.mocks.Acknowledge, ms...)
	imit.lockAcknowledge.Unlock()
}

// Acknowledge Take Records
func (imit *ImitSubscriberServer) TakeAcknowledgeRecords() []struct {
	P0 context.Context
	P1 *pubsub.AcknowledgeRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.AcknowledgeRequest
	}

	// clear records
	imit.lockAcknowledge.Lock()
	records = imit.records.Acknowledge
	imit.records.Acknowledge = nil
	imit.lockAcknowledge.Unlock()

	return records
}

// Acknowledge Imitation
func (imit *ImitSubscriberServer) Acknowledge(P0 context.Context, P1 *pubsub.AcknowledgeRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.Acknowledge) == 0 {
		panic("ImitSubscriberServer.Acknowledge mocks is nil but ImitSubscriberServer.Acknowledge was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.AcknowledgeRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockAcknowledge.Lock()
	// record call
	imit.records.Acknowledge = append(imit.records.Acknowledge, call)
	// pop mock
	mockFunc := imit.mocks.Acknowledge[0]
	imit.mocks.Acknowledge = imit.mocks.Acknowledge[1:]
	imit.lockAcknowledge.Unlock()

	return mockFunc(P0, P1)
}

// CreateSnapshot Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueCreateSnapshotMock(m func(P0 context.Context, P1 *pubsub.CreateSnapshotRequest) (*pubsub.Snapshot, error)) {
	imit.lockCreateSnapshot.Lock()
	imit.mocks.CreateSnapshot = append(imit.mocks.CreateSnapshot, m)
	imit.lockCreateSnapshot.Unlock()
}

// CreateSnapshot Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueCreateSnapshotMocks(ms []func(P0 context.Context, P1 *pubsub.CreateSnapshotRequest) (*pubsub.Snapshot, error)) {
	imit.lockCreateSnapshot.Lock()
	imit.mocks.CreateSnapshot = append(imit.mocks.CreateSnapshot, ms...)
	imit.lockCreateSnapshot.Unlock()
}

// CreateSnapshot Take Records
func (imit *ImitSubscriberServer) TakeCreateSnapshotRecords() []struct {
	P0 context.Context
	P1 *pubsub.CreateSnapshotRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.CreateSnapshotRequest
	}

	// clear records
	imit.lockCreateSnapshot.Lock()
	records = imit.records.CreateSnapshot
	imit.records.CreateSnapshot = nil
	imit.lockCreateSnapshot.Unlock()

	return records
}

// CreateSnapshot Imitation
func (imit *ImitSubscriberServer) CreateSnapshot(P0 context.Context, P1 *pubsub.CreateSnapshotRequest) (*pubsub.Snapshot, error) {
	if len(imit.mocks.CreateSnapshot) == 0 {
		panic("ImitSubscriberServer.CreateSnapshot mocks is nil but ImitSubscriberServer.CreateSnapshot was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.CreateSnapshotRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockCreateSnapshot.Lock()
	// record call
	imit.records.CreateSnapshot = append(imit.records.CreateSnapshot, call)
	// pop mock
	mockFunc := imit.mocks.CreateSnapshot[0]
	imit.mocks.CreateSnapshot = imit.mocks.CreateSnapshot[1:]
	imit.lockCreateSnapshot.Unlock()

	return mockFunc(P0, P1)
}

// CreateSubscription Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueCreateSubscriptionMock(m func(P0 context.Context, P1 *pubsub.Subscription) (*pubsub.Subscription, error)) {
	imit.lockCreateSubscription.Lock()
	imit.mocks.CreateSubscription = append(imit.mocks.CreateSubscription, m)
	imit.lockCreateSubscription.Unlock()
}

// CreateSubscription Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueCreateSubscriptionMocks(ms []func(P0 context.Context, P1 *pubsub.Subscription) (*pubsub.Subscription, error)) {
	imit.lockCreateSubscription.Lock()
	imit.mocks.CreateSubscription = append(imit.mocks.CreateSubscription, ms...)
	imit.lockCreateSubscription.Unlock()
}

// CreateSubscription Take Records
func (imit *ImitSubscriberServer) TakeCreateSubscriptionRecords() []struct {
	P0 context.Context
	P1 *pubsub.Subscription
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.Subscription
	}

	// clear records
	imit.lockCreateSubscription.Lock()
	records = imit.records.CreateSubscription
	imit.records.CreateSubscription = nil
	imit.lockCreateSubscription.Unlock()

	return records
}

// CreateSubscription Imitation
func (imit *ImitSubscriberServer) CreateSubscription(P0 context.Context, P1 *pubsub.Subscription) (*pubsub.Subscription, error) {
	if len(imit.mocks.CreateSubscription) == 0 {
		panic("ImitSubscriberServer.CreateSubscription mocks is nil but ImitSubscriberServer.CreateSubscription was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.Subscription
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockCreateSubscription.Lock()
	// record call
	imit.records.CreateSubscription = append(imit.records.CreateSubscription, call)
	// pop mock
	mockFunc := imit.mocks.CreateSubscription[0]
	imit.mocks.CreateSubscription = imit.mocks.CreateSubscription[1:]
	imit.lockCreateSubscription.Unlock()

	return mockFunc(P0, P1)
}

// DeleteSnapshot Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueDeleteSnapshotMock(m func(P0 context.Context, P1 *pubsub.DeleteSnapshotRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteSnapshot.Lock()
	imit.mocks.DeleteSnapshot = append(imit.mocks.DeleteSnapshot, m)
	imit.lockDeleteSnapshot.Unlock()
}

// DeleteSnapshot Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueDeleteSnapshotMocks(ms []func(P0 context.Context, P1 *pubsub.DeleteSnapshotRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteSnapshot.Lock()
	imit.mocks.DeleteSnapshot = append(imit.mocks.DeleteSnapshot, ms...)
	imit.lockDeleteSnapshot.Unlock()
}

// DeleteSnapshot Take Records
func (imit *ImitSubscriberServer) TakeDeleteSnapshotRecords() []struct {
	P0 context.Context
	P1 *pubsub.DeleteSnapshotRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.DeleteSnapshotRequest
	}

	// clear records
	imit.lockDeleteSnapshot.Lock()
	records = imit.records.DeleteSnapshot
	imit.records.DeleteSnapshot = nil
	imit.lockDeleteSnapshot.Unlock()

	return records
}

// DeleteSnapshot Imitation
func (imit *ImitSubscriberServer) DeleteSnapshot(P0 context.Context, P1 *pubsub.DeleteSnapshotRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.DeleteSnapshot) == 0 {
		panic("ImitSubscriberServer.DeleteSnapshot mocks is nil but ImitSubscriberServer.DeleteSnapshot was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.DeleteSnapshotRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockDeleteSnapshot.Lock()
	// record call
	imit.records.DeleteSnapshot = append(imit.records.DeleteSnapshot, call)
	// pop mock
	mockFunc := imit.mocks.DeleteSnapshot[0]
	imit.mocks.DeleteSnapshot = imit.mocks.DeleteSnapshot[1:]
	imit.lockDeleteSnapshot.Unlock()

	return mockFunc(P0, P1)
}

// DeleteSubscription Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueDeleteSubscriptionMock(m func(P0 context.Context, P1 *pubsub.DeleteSubscriptionRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteSubscription.Lock()
	imit.mocks.DeleteSubscription = append(imit.mocks.DeleteSubscription, m)
	imit.lockDeleteSubscription.Unlock()
}

// DeleteSubscription Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueDeleteSubscriptionMocks(ms []func(P0 context.Context, P1 *pubsub.DeleteSubscriptionRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteSubscription.Lock()
	imit.mocks.DeleteSubscription = append(imit.mocks.DeleteSubscription, ms...)
	imit.lockDeleteSubscription.Unlock()
}

// DeleteSubscription Take Records
func (imit *ImitSubscriberServer) TakeDeleteSubscriptionRecords() []struct {
	P0 context.Context
	P1 *pubsub.DeleteSubscriptionRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.DeleteSubscriptionRequest
	}

	// clear records
	imit.lockDeleteSubscription.Lock()
	records = imit.records.DeleteSubscription
	imit.records.DeleteSubscription = nil
	imit.lockDeleteSubscription.Unlock()

	return records
}

// DeleteSubscription Imitation
func (imit *ImitSubscriberServer) DeleteSubscription(P0 context.Context, P1 *pubsub.DeleteSubscriptionRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.DeleteSubscription) == 0 {
		panic("ImitSubscriberServer.DeleteSubscription mocks is nil but ImitSubscriberServer.DeleteSubscription was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.DeleteSubscriptionRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockDeleteSubscription.Lock()
	// record call
	imit.records.DeleteSubscription = append(imit.records.DeleteSubscription, call)
	// pop mock
	mockFunc := imit.mocks.DeleteSubscription[0]
	imit.mocks.DeleteSubscription = imit.mocks.DeleteSubscription[1:]
	imit.lockDeleteSubscription.Unlock()

	return mockFunc(P0, P1)
}

// GetSnapshot Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueGetSnapshotMock(m func(P0 context.Context, P1 *pubsub.GetSnapshotRequest) (*pubsub.Snapshot, error)) {
	imit.lockGetSnapshot.Lock()
	imit.mocks.GetSnapshot = append(imit.mocks.GetSnapshot, m)
	imit.lockGetSnapshot.Unlock()
}

// GetSnapshot Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueGetSnapshotMocks(ms []func(P0 context.Context, P1 *pubsub.GetSnapshotRequest) (*pubsub.Snapshot, error)) {
	imit.lockGetSnapshot.Lock()
	imit.mocks.GetSnapshot = append(imit.mocks.GetSnapshot, ms...)
	imit.lockGetSnapshot.Unlock()
}

// GetSnapshot Take Records
func (imit *ImitSubscriberServer) TakeGetSnapshotRecords() []struct {
	P0 context.Context
	P1 *pubsub.GetSnapshotRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.GetSnapshotRequest
	}

	// clear records
	imit.lockGetSnapshot.Lock()
	records = imit.records.GetSnapshot
	imit.records.GetSnapshot = nil
	imit.lockGetSnapshot.Unlock()

	return records
}

// GetSnapshot Imitation
func (imit *ImitSubscriberServer) GetSnapshot(P0 context.Context, P1 *pubsub.GetSnapshotRequest) (*pubsub.Snapshot, error) {
	if len(imit.mocks.GetSnapshot) == 0 {
		panic("ImitSubscriberServer.GetSnapshot mocks is nil but ImitSubscriberServer.GetSnapshot was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.GetSnapshotRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockGetSnapshot.Lock()
	// record call
	imit.records.GetSnapshot = append(imit.records.GetSnapshot, call)
	// pop mock
	mockFunc := imit.mocks.GetSnapshot[0]
	imit.mocks.GetSnapshot = imit.mocks.GetSnapshot[1:]
	imit.lockGetSnapshot.Unlock()

	return mockFunc(P0, P1)
}

// GetSubscription Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueGetSubscriptionMock(m func(P0 context.Context, P1 *pubsub.GetSubscriptionRequest) (*pubsub.Subscription, error)) {
	imit.lockGetSubscription.Lock()
	imit.mocks.GetSubscription = append(imit.mocks.GetSubscription, m)
	imit.lockGetSubscription.Unlock()
}

// GetSubscription Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueGetSubscriptionMocks(ms []func(P0 context.Context, P1 *pubsub.GetSubscriptionRequest) (*pubsub.Subscription, error)) {
	imit.lockGetSubscription.Lock()
	imit.mocks.GetSubscription = append(imit.mocks.GetSubscription, ms...)
	imit.lockGetSubscription.Unlock()
}

// GetSubscription Take Records
func (imit *ImitSubscriberServer) TakeGetSubscriptionRecords() []struct {
	P0 context.Context
	P1 *pubsub.GetSubscriptionRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.GetSubscriptionRequest
	}

	// clear records
	imit.lockGetSubscription.Lock()
	records = imit.records.GetSubscription
	imit.records.GetSubscription = nil
	imit.lockGetSubscription.Unlock()

	return records
}

// GetSubscription Imitation
func (imit *ImitSubscriberServer) GetSubscription(P0 context.Context, P1 *pubsub.GetSubscriptionRequest) (*pubsub.Subscription, error) {
	if len(imit.mocks.GetSubscription) == 0 {
		panic("ImitSubscriberServer.GetSubscription mocks is nil but ImitSubscriberServer.GetSubscription was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.GetSubscriptionRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockGetSubscription.Lock()
	// record call
	imit.records.GetSubscription = append(imit.records.GetSubscription, call)
	// pop mock
	mockFunc := imit.mocks.GetSubscription[0]
	imit.mocks.GetSubscription = imit.mocks.GetSubscription[1:]
	imit.lockGetSubscription.Unlock()

	return mockFunc(P0, P1)
}

// ListSnapshots Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueListSnapshotsMock(m func(P0 context.Context, P1 *pubsub.ListSnapshotsRequest) (*pubsub.ListSnapshotsResponse, error)) {
	imit.lockListSnapshots.Lock()
	imit.mocks.ListSnapshots = append(imit.mocks.ListSnapshots, m)
	imit.lockListSnapshots.Unlock()
}

// ListSnapshots Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueListSnapshotsMocks(ms []func(P0 context.Context, P1 *pubsub.ListSnapshotsRequest) (*pubsub.ListSnapshotsResponse, error)) {
	imit.lockListSnapshots.Lock()
	imit.mocks.ListSnapshots = append(imit.mocks.ListSnapshots, ms...)
	imit.lockListSnapshots.Unlock()
}

// ListSnapshots Take Records
func (imit *ImitSubscriberServer) TakeListSnapshotsRecords() []struct {
	P0 context.Context
	P1 *pubsub.ListSnapshotsRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ListSnapshotsRequest
	}

	// clear records
	imit.lockListSnapshots.Lock()
	records = imit.records.ListSnapshots
	imit.records.ListSnapshots = nil
	imit.lockListSnapshots.Unlock()

	return records
}

// ListSnapshots Imitation
func (imit *ImitSubscriberServer) ListSnapshots(P0 context.Context, P1 *pubsub.ListSnapshotsRequest) (*pubsub.ListSnapshotsResponse, error) {
	if len(imit.mocks.ListSnapshots) == 0 {
		panic("ImitSubscriberServer.ListSnapshots mocks is nil but ImitSubscriberServer.ListSnapshots was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ListSnapshotsRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListSnapshots.Lock()
	// record call
	imit.records.ListSnapshots = append(imit.records.ListSnapshots, call)
	// pop mock
	mockFunc := imit.mocks.ListSnapshots[0]
	imit.mocks.ListSnapshots = imit.mocks.ListSnapshots[1:]
	imit.lockListSnapshots.Unlock()

	return mockFunc(P0, P1)
}

// ListSubscriptions Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueListSubscriptionsMock(m func(P0 context.Context, P1 *pubsub.ListSubscriptionsRequest) (*pubsub.ListSubscriptionsResponse, error)) {
	imit.lockListSubscriptions.Lock()
	imit.mocks.ListSubscriptions = append(imit.mocks.ListSubscriptions, m)
	imit.lockListSubscriptions.Unlock()
}

// ListSubscriptions Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueListSubscriptionsMocks(ms []func(P0 context.Context, P1 *pubsub.ListSubscriptionsRequest) (*pubsub.ListSubscriptionsResponse, error)) {
	imit.lockListSubscriptions.Lock()
	imit.mocks.ListSubscriptions = append(imit.mocks.ListSubscriptions, ms...)
	imit.lockListSubscriptions.Unlock()
}

// ListSubscriptions Take Records
func (imit *ImitSubscriberServer) TakeListSubscriptionsRecords() []struct {
	P0 context.Context
	P1 *pubsub.ListSubscriptionsRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ListSubscriptionsRequest
	}

	// clear records
	imit.lockListSubscriptions.Lock()
	records = imit.records.ListSubscriptions
	imit.records.ListSubscriptions = nil
	imit.lockListSubscriptions.Unlock()

	return records
}

// ListSubscriptions Imitation
func (imit *ImitSubscriberServer) ListSubscriptions(P0 context.Context, P1 *pubsub.ListSubscriptionsRequest) (*pubsub.ListSubscriptionsResponse, error) {
	if len(imit.mocks.ListSubscriptions) == 0 {
		panic("ImitSubscriberServer.ListSubscriptions mocks is nil but ImitSubscriberServer.ListSubscriptions was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ListSubscriptionsRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListSubscriptions.Lock()
	// record call
	imit.records.ListSubscriptions = append(imit.records.ListSubscriptions, call)
	// pop mock
	mockFunc := imit.mocks.ListSubscriptions[0]
	imit.mocks.ListSubscriptions = imit.mocks.ListSubscriptions[1:]
	imit.lockListSubscriptions.Unlock()

	return mockFunc(P0, P1)
}

// ModifyAckDeadline Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueModifyAckDeadlineMock(m func(P0 context.Context, P1 *pubsub.ModifyAckDeadlineRequest) (*emptypb.Empty, error)) {
	imit.lockModifyAckDeadline.Lock()
	imit.mocks.ModifyAckDeadline = append(imit.mocks.ModifyAckDeadline, m)
	imit.lockModifyAckDeadline.Unlock()
}

// ModifyAckDeadline Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueModifyAckDeadlineMocks(ms []func(P0 context.Context, P1 *pubsub.ModifyAckDeadlineRequest) (*emptypb.Empty, error)) {
	imit.lockModifyAckDeadline.Lock()
	imit.mocks.ModifyAckDeadline = append(imit.mocks.ModifyAckDeadline, ms...)
	imit.lockModifyAckDeadline.Unlock()
}

// ModifyAckDeadline Take Records
func (imit *ImitSubscriberServer) TakeModifyAckDeadlineRecords() []struct {
	P0 context.Context
	P1 *pubsub.ModifyAckDeadlineRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ModifyAckDeadlineRequest
	}

	// clear records
	imit.lockModifyAckDeadline.Lock()
	records = imit.records.ModifyAckDeadline
	imit.records.ModifyAckDeadline = nil
	imit.lockModifyAckDeadline.Unlock()

	return records
}

// ModifyAckDeadline Imitation
func (imit *ImitSubscriberServer) ModifyAckDeadline(P0 context.Context, P1 *pubsub.ModifyAckDeadlineRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.ModifyAckDeadline) == 0 {
		panic("ImitSubscriberServer.ModifyAckDeadline mocks is nil but ImitSubscriberServer.ModifyAckDeadline was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ModifyAckDeadlineRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockModifyAckDeadline.Lock()
	// record call
	imit.records.ModifyAckDeadline = append(imit.records.ModifyAckDeadline, call)
	// pop mock
	mockFunc := imit.mocks.ModifyAckDeadline[0]
	imit.mocks.ModifyAckDeadline = imit.mocks.ModifyAckDeadline[1:]
	imit.lockModifyAckDeadline.Unlock()

	return mockFunc(P0, P1)
}

// ModifyPushConfig Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueModifyPushConfigMock(m func(P0 context.Context, P1 *pubsub.ModifyPushConfigRequest) (*emptypb.Empty, error)) {
	imit.lockModifyPushConfig.Lock()
	imit.mocks.ModifyPushConfig = append(imit.mocks.ModifyPushConfig, m)
	imit.lockModifyPushConfig.Unlock()
}

// ModifyPushConfig Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueModifyPushConfigMocks(ms []func(P0 context.Context, P1 *pubsub.ModifyPushConfigRequest) (*emptypb.Empty, error)) {
	imit.lockModifyPushConfig.Lock()
	imit.mocks.ModifyPushConfig = append(imit.mocks.ModifyPushConfig, ms...)
	imit.lockModifyPushConfig.Unlock()
}

// ModifyPushConfig Take Records
func (imit *ImitSubscriberServer) TakeModifyPushConfigRecords() []struct {
	P0 context.Context
	P1 *pubsub.ModifyPushConfigRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.ModifyPushConfigRequest
	}

	// clear records
	imit.lockModifyPushConfig.Lock()
	records = imit.records.ModifyPushConfig
	imit.records.ModifyPushConfig = nil
	imit.lockModifyPushConfig.Unlock()

	return records
}

// ModifyPushConfig Imitation
func (imit *ImitSubscriberServer) ModifyPushConfig(P0 context.Context, P1 *pubsub.ModifyPushConfigRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.ModifyPushConfig) == 0 {
		panic("ImitSubscriberServer.ModifyPushConfig mocks is nil but ImitSubscriberServer.ModifyPushConfig was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.ModifyPushConfigRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockModifyPushConfig.Lock()
	// record call
	imit.records.ModifyPushConfig = append(imit.records.ModifyPushConfig, call)
	// pop mock
	mockFunc := imit.mocks.ModifyPushConfig[0]
	imit.mocks.ModifyPushConfig = imit.mocks.ModifyPushConfig[1:]
	imit.lockModifyPushConfig.Unlock()

	return mockFunc(P0, P1)
}

// Pull Enqueue Mock
func (imit *ImitSubscriberServer) EnqueuePullMock(m func(P0 context.Context, P1 *pubsub.PullRequest) (*pubsub.PullResponse, error)) {
	imit.lockPull.Lock()
	imit.mocks.Pull = append(imit.mocks.Pull, m)
	imit.lockPull.Unlock()
}

// Pull Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueuePullMocks(ms []func(P0 context.Context, P1 *pubsub.PullRequest) (*pubsub.PullResponse, error)) {
	imit.lockPull.Lock()
	imit.mocks.Pull = append(imit.mocks.Pull, ms...)
	imit.lockPull.Unlock()
}

// Pull Take Records
func (imit *ImitSubscriberServer) TakePullRecords() []struct {
	P0 context.Context
	P1 *pubsub.PullRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.PullRequest
	}

	// clear records
	imit.lockPull.Lock()
	records = imit.records.Pull
	imit.records.Pull = nil
	imit.lockPull.Unlock()

	return records
}

// Pull Imitation
func (imit *ImitSubscriberServer) Pull(P0 context.Context, P1 *pubsub.PullRequest) (*pubsub.PullResponse, error) {
	if len(imit.mocks.Pull) == 0 {
		panic("ImitSubscriberServer.Pull mocks is nil but ImitSubscriberServer.Pull was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.PullRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockPull.Lock()
	// record call
	imit.records.Pull = append(imit.records.Pull, call)
	// pop mock
	mockFunc := imit.mocks.Pull[0]
	imit.mocks.Pull = imit.mocks.Pull[1:]
	imit.lockPull.Unlock()

	return mockFunc(P0, P1)
}

// Seek Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueSeekMock(m func(P0 context.Context, P1 *pubsub.SeekRequest) (*pubsub.SeekResponse, error)) {
	imit.lockSeek.Lock()
	imit.mocks.Seek = append(imit.mocks.Seek, m)
	imit.lockSeek.Unlock()
}

// Seek Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueSeekMocks(ms []func(P0 context.Context, P1 *pubsub.SeekRequest) (*pubsub.SeekResponse, error)) {
	imit.lockSeek.Lock()
	imit.mocks.Seek = append(imit.mocks.Seek, ms...)
	imit.lockSeek.Unlock()
}

// Seek Take Records
func (imit *ImitSubscriberServer) TakeSeekRecords() []struct {
	P0 context.Context
	P1 *pubsub.SeekRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.SeekRequest
	}

	// clear records
	imit.lockSeek.Lock()
	records = imit.records.Seek
	imit.records.Seek = nil
	imit.lockSeek.Unlock()

	return records
}

// Seek Imitation
func (imit *ImitSubscriberServer) Seek(P0 context.Context, P1 *pubsub.SeekRequest) (*pubsub.SeekResponse, error) {
	if len(imit.mocks.Seek) == 0 {
		panic("ImitSubscriberServer.Seek mocks is nil but ImitSubscriberServer.Seek was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.SeekRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockSeek.Lock()
	// record call
	imit.records.Seek = append(imit.records.Seek, call)
	// pop mock
	mockFunc := imit.mocks.Seek[0]
	imit.mocks.Seek = imit.mocks.Seek[1:]
	imit.lockSeek.Unlock()

	return mockFunc(P0, P1)
}

// StreamingPull Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueStreamingPullMock(m func(P0 pubsub.Subscriber_StreamingPullServer) error) {
	imit.lockStreamingPull.Lock()
	imit.mocks.StreamingPull = append(imit.mocks.StreamingPull, m)
	imit.lockStreamingPull.Unlock()
}

// StreamingPull Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueStreamingPullMocks(ms []func(P0 pubsub.Subscriber_StreamingPullServer) error) {
	imit.lockStreamingPull.Lock()
	imit.mocks.StreamingPull = append(imit.mocks.StreamingPull, ms...)
	imit.lockStreamingPull.Unlock()
}

// StreamingPull Take Records
func (imit *ImitSubscriberServer) TakeStreamingPullRecords() []struct {
	P0 pubsub.Subscriber_StreamingPullServer
} {
	var records []struct {
		P0 pubsub.Subscriber_StreamingPullServer
	}

	// clear records
	imit.lockStreamingPull.Lock()
	records = imit.records.StreamingPull
	imit.records.StreamingPull = nil
	imit.lockStreamingPull.Unlock()

	return records
}

// StreamingPull Imitation
func (imit *ImitSubscriberServer) StreamingPull(P0 pubsub.Subscriber_StreamingPullServer) error {
	if len(imit.mocks.StreamingPull) == 0 {
		panic("ImitSubscriberServer.StreamingPull mocks is nil but ImitSubscriberServer.StreamingPull was just called")
	}

	call := struct {
		P0 pubsub.Subscriber_StreamingPullServer
	}{
		P0: P0,
	}

	imit.lockStreamingPull.Lock()
	// record call
	imit.records.StreamingPull = append(imit.records.StreamingPull, call)
	// pop mock
	mockFunc := imit.mocks.StreamingPull[0]
	imit.mocks.StreamingPull = imit.mocks.StreamingPull[1:]
	imit.lockStreamingPull.Unlock()

	return mockFunc(P0)
}

// UpdateSnapshot Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueUpdateSnapshotMock(m func(P0 context.Context, P1 *pubsub.UpdateSnapshotRequest) (*pubsub.Snapshot, error)) {
	imit.lockUpdateSnapshot.Lock()
	imit.mocks.UpdateSnapshot = append(imit.mocks.UpdateSnapshot, m)
	imit.lockUpdateSnapshot.Unlock()
}

// UpdateSnapshot Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueUpdateSnapshotMocks(ms []func(P0 context.Context, P1 *pubsub.UpdateSnapshotRequest) (*pubsub.Snapshot, error)) {
	imit.lockUpdateSnapshot.Lock()
	imit.mocks.UpdateSnapshot = append(imit.mocks.UpdateSnapshot, ms...)
	imit.lockUpdateSnapshot.Unlock()
}

// UpdateSnapshot Take Records
func (imit *ImitSubscriberServer) TakeUpdateSnapshotRecords() []struct {
	P0 context.Context
	P1 *pubsub.UpdateSnapshotRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.UpdateSnapshotRequest
	}

	// clear records
	imit.lockUpdateSnapshot.Lock()
	records = imit.records.UpdateSnapshot
	imit.records.UpdateSnapshot = nil
	imit.lockUpdateSnapshot.Unlock()

	return records
}

// UpdateSnapshot Imitation
func (imit *ImitSubscriberServer) UpdateSnapshot(P0 context.Context, P1 *pubsub.UpdateSnapshotRequest) (*pubsub.Snapshot, error) {
	if len(imit.mocks.UpdateSnapshot) == 0 {
		panic("ImitSubscriberServer.UpdateSnapshot mocks is nil but ImitSubscriberServer.UpdateSnapshot was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.UpdateSnapshotRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockUpdateSnapshot.Lock()
	// record call
	imit.records.UpdateSnapshot = append(imit.records.UpdateSnapshot, call)
	// pop mock
	mockFunc := imit.mocks.UpdateSnapshot[0]
	imit.mocks.UpdateSnapshot = imit.mocks.UpdateSnapshot[1:]
	imit.lockUpdateSnapshot.Unlock()

	return mockFunc(P0, P1)
}

// UpdateSubscription Enqueue Mock
func (imit *ImitSubscriberServer) EnqueueUpdateSubscriptionMock(m func(P0 context.Context, P1 *pubsub.UpdateSubscriptionRequest) (*pubsub.Subscription, error)) {
	imit.lockUpdateSubscription.Lock()
	imit.mocks.UpdateSubscription = append(imit.mocks.UpdateSubscription, m)
	imit.lockUpdateSubscription.Unlock()
}

// UpdateSubscription Enqueue Mocks
func (imit *ImitSubscriberServer) EnqueueUpdateSubscriptionMocks(ms []func(P0 context.Context, P1 *pubsub.UpdateSubscriptionRequest) (*pubsub.Subscription, error)) {
	imit.lockUpdateSubscription.Lock()
	imit.mocks.UpdateSubscription = append(imit.mocks.UpdateSubscription, ms...)
	imit.lockUpdateSubscription.Unlock()
}

// UpdateSubscription Take Records
func (imit *ImitSubscriberServer) TakeUpdateSubscriptionRecords() []struct {
	P0 context.Context
	P1 *pubsub.UpdateSubscriptionRequest
} {
	var records []struct {
		P0 context.Context
		P1 *pubsub.UpdateSubscriptionRequest
	}

	// clear records
	imit.lockUpdateSubscription.Lock()
	records = imit.records.UpdateSubscription
	imit.records.UpdateSubscription = nil
	imit.lockUpdateSubscription.Unlock()

	return records
}

// UpdateSubscription Imitation
func (imit *ImitSubscriberServer) UpdateSubscription(P0 context.Context, P1 *pubsub.UpdateSubscriptionRequest) (*pubsub.Subscription, error) {
	if len(imit.mocks.UpdateSubscription) == 0 {
		panic("ImitSubscriberServer.UpdateSubscription mocks is nil but ImitSubscriberServer.UpdateSubscription was just called")
	}

	call := struct {
		P0 context.Context
		P1 *pubsub.UpdateSubscriptionRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockUpdateSubscription.Lock()
	// record call
	imit.records.UpdateSubscription = append(imit.records.UpdateSubscription, call)
	// pop mock
	mockFunc := imit.mocks.UpdateSubscription[0]
	imit.mocks.UpdateSubscription = imit.mocks.UpdateSubscription[1:]
	imit.lockUpdateSubscription.Unlock()

	return mockFunc(P0, P1)
}
