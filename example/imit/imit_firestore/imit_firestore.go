// Code generated by go-grpc-imit-gen; DO NOT EDIT.
// github.com/n6o/go-grpc-imit-gen

package imit_firestore

import (
	context "context"
	sync "sync"

	firestore "google.golang.org/genproto/googleapis/firestore/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

var _ firestore.FirestoreServer = &ImitFirestoreServer{}

type ImitFirestoreServer struct {
	firestore.UnimplementedFirestoreServer

	// mocks
	mocks struct {
		BatchGetDocuments []func(P0 *firestore.BatchGetDocumentsRequest, P1 firestore.Firestore_BatchGetDocumentsServer) error
		BatchWrite        []func(P0 context.Context, P1 *firestore.BatchWriteRequest) (*firestore.BatchWriteResponse, error)
		BeginTransaction  []func(P0 context.Context, P1 *firestore.BeginTransactionRequest) (*firestore.BeginTransactionResponse, error)
		Commit            []func(P0 context.Context, P1 *firestore.CommitRequest) (*firestore.CommitResponse, error)
		CreateDocument    []func(P0 context.Context, P1 *firestore.CreateDocumentRequest) (*firestore.Document, error)
		DeleteDocument    []func(P0 context.Context, P1 *firestore.DeleteDocumentRequest) (*emptypb.Empty, error)
		GetDocument       []func(P0 context.Context, P1 *firestore.GetDocumentRequest) (*firestore.Document, error)
		ListCollectionIds []func(P0 context.Context, P1 *firestore.ListCollectionIdsRequest) (*firestore.ListCollectionIdsResponse, error)
		ListDocuments     []func(P0 context.Context, P1 *firestore.ListDocumentsRequest) (*firestore.ListDocumentsResponse, error)
		Listen            []func(P0 firestore.Firestore_ListenServer) error
		PartitionQuery    []func(P0 context.Context, P1 *firestore.PartitionQueryRequest) (*firestore.PartitionQueryResponse, error)
		Rollback          []func(P0 context.Context, P1 *firestore.RollbackRequest) (*emptypb.Empty, error)
		RunQuery          []func(P0 *firestore.RunQueryRequest, P1 firestore.Firestore_RunQueryServer) error
		UpdateDocument    []func(P0 context.Context, P1 *firestore.UpdateDocumentRequest) (*firestore.Document, error)
		Write             []func(P0 firestore.Firestore_WriteServer) error
	}

	// records
	records struct {
		BatchGetDocuments []struct {
			P0 *firestore.BatchGetDocumentsRequest
			P1 firestore.Firestore_BatchGetDocumentsServer
		}
		BatchWrite []struct {
			P0 context.Context
			P1 *firestore.BatchWriteRequest
		}
		BeginTransaction []struct {
			P0 context.Context
			P1 *firestore.BeginTransactionRequest
		}
		Commit []struct {
			P0 context.Context
			P1 *firestore.CommitRequest
		}
		CreateDocument []struct {
			P0 context.Context
			P1 *firestore.CreateDocumentRequest
		}
		DeleteDocument []struct {
			P0 context.Context
			P1 *firestore.DeleteDocumentRequest
		}
		GetDocument []struct {
			P0 context.Context
			P1 *firestore.GetDocumentRequest
		}
		ListCollectionIds []struct {
			P0 context.Context
			P1 *firestore.ListCollectionIdsRequest
		}
		ListDocuments []struct {
			P0 context.Context
			P1 *firestore.ListDocumentsRequest
		}
		Listen []struct {
			P0 firestore.Firestore_ListenServer
		}
		PartitionQuery []struct {
			P0 context.Context
			P1 *firestore.PartitionQueryRequest
		}
		Rollback []struct {
			P0 context.Context
			P1 *firestore.RollbackRequest
		}
		RunQuery []struct {
			P0 *firestore.RunQueryRequest
			P1 firestore.Firestore_RunQueryServer
		}
		UpdateDocument []struct {
			P0 context.Context
			P1 *firestore.UpdateDocumentRequest
		}
		Write []struct {
			P0 firestore.Firestore_WriteServer
		}
	}

	// locks
	lockBatchGetDocuments sync.RWMutex
	lockBatchWrite        sync.RWMutex
	lockBeginTransaction  sync.RWMutex
	lockCommit            sync.RWMutex
	lockCreateDocument    sync.RWMutex
	lockDeleteDocument    sync.RWMutex
	lockGetDocument       sync.RWMutex
	lockListCollectionIds sync.RWMutex
	lockListDocuments     sync.RWMutex
	lockListen            sync.RWMutex
	lockPartitionQuery    sync.RWMutex
	lockRollback          sync.RWMutex
	lockRunQuery          sync.RWMutex
	lockUpdateDocument    sync.RWMutex
	lockWrite             sync.RWMutex
}

// BatchGetDocuments Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueBatchGetDocumentsMock(m func(P0 *firestore.BatchGetDocumentsRequest, P1 firestore.Firestore_BatchGetDocumentsServer) error) {
	imit.lockBatchGetDocuments.Lock()
	imit.mocks.BatchGetDocuments = append(imit.mocks.BatchGetDocuments, m)
	imit.lockBatchGetDocuments.Unlock()
}

// BatchGetDocuments Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueBatchGetDocumentsMocks(ms []func(P0 *firestore.BatchGetDocumentsRequest, P1 firestore.Firestore_BatchGetDocumentsServer) error) {
	imit.lockBatchGetDocuments.Lock()
	imit.mocks.BatchGetDocuments = append(imit.mocks.BatchGetDocuments, ms...)
	imit.lockBatchGetDocuments.Unlock()
}

// BatchGetDocuments Take Records
func (imit *ImitFirestoreServer) TakeBatchGetDocumentsRecords() []struct {
	P0 *firestore.BatchGetDocumentsRequest
	P1 firestore.Firestore_BatchGetDocumentsServer
} {
	var records []struct {
		P0 *firestore.BatchGetDocumentsRequest
		P1 firestore.Firestore_BatchGetDocumentsServer
	}

	// clear records
	imit.lockBatchGetDocuments.Lock()
	records = imit.records.BatchGetDocuments
	imit.records.BatchGetDocuments = nil
	imit.lockBatchGetDocuments.Unlock()

	return records
}

// BatchGetDocuments Imitation
func (imit *ImitFirestoreServer) BatchGetDocuments(P0 *firestore.BatchGetDocumentsRequest, P1 firestore.Firestore_BatchGetDocumentsServer) error {
	if len(imit.mocks.BatchGetDocuments) == 0 {
		panic("ImitFirestoreServer.BatchGetDocuments mocks is nil but ImitFirestoreServer.BatchGetDocuments was just called")
	}

	call := struct {
		P0 *firestore.BatchGetDocumentsRequest
		P1 firestore.Firestore_BatchGetDocumentsServer
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockBatchGetDocuments.Lock()
	// record call
	imit.records.BatchGetDocuments = append(imit.records.BatchGetDocuments, call)
	// pop mock
	mockFunc := imit.mocks.BatchGetDocuments[0]
	imit.mocks.BatchGetDocuments = imit.mocks.BatchGetDocuments[1:]
	imit.lockBatchGetDocuments.Unlock()

	return mockFunc(P0, P1)
}

// BatchWrite Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueBatchWriteMock(m func(P0 context.Context, P1 *firestore.BatchWriteRequest) (*firestore.BatchWriteResponse, error)) {
	imit.lockBatchWrite.Lock()
	imit.mocks.BatchWrite = append(imit.mocks.BatchWrite, m)
	imit.lockBatchWrite.Unlock()
}

// BatchWrite Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueBatchWriteMocks(ms []func(P0 context.Context, P1 *firestore.BatchWriteRequest) (*firestore.BatchWriteResponse, error)) {
	imit.lockBatchWrite.Lock()
	imit.mocks.BatchWrite = append(imit.mocks.BatchWrite, ms...)
	imit.lockBatchWrite.Unlock()
}

// BatchWrite Take Records
func (imit *ImitFirestoreServer) TakeBatchWriteRecords() []struct {
	P0 context.Context
	P1 *firestore.BatchWriteRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.BatchWriteRequest
	}

	// clear records
	imit.lockBatchWrite.Lock()
	records = imit.records.BatchWrite
	imit.records.BatchWrite = nil
	imit.lockBatchWrite.Unlock()

	return records
}

// BatchWrite Imitation
func (imit *ImitFirestoreServer) BatchWrite(P0 context.Context, P1 *firestore.BatchWriteRequest) (*firestore.BatchWriteResponse, error) {
	if len(imit.mocks.BatchWrite) == 0 {
		panic("ImitFirestoreServer.BatchWrite mocks is nil but ImitFirestoreServer.BatchWrite was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.BatchWriteRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockBatchWrite.Lock()
	// record call
	imit.records.BatchWrite = append(imit.records.BatchWrite, call)
	// pop mock
	mockFunc := imit.mocks.BatchWrite[0]
	imit.mocks.BatchWrite = imit.mocks.BatchWrite[1:]
	imit.lockBatchWrite.Unlock()

	return mockFunc(P0, P1)
}

// BeginTransaction Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueBeginTransactionMock(m func(P0 context.Context, P1 *firestore.BeginTransactionRequest) (*firestore.BeginTransactionResponse, error)) {
	imit.lockBeginTransaction.Lock()
	imit.mocks.BeginTransaction = append(imit.mocks.BeginTransaction, m)
	imit.lockBeginTransaction.Unlock()
}

// BeginTransaction Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueBeginTransactionMocks(ms []func(P0 context.Context, P1 *firestore.BeginTransactionRequest) (*firestore.BeginTransactionResponse, error)) {
	imit.lockBeginTransaction.Lock()
	imit.mocks.BeginTransaction = append(imit.mocks.BeginTransaction, ms...)
	imit.lockBeginTransaction.Unlock()
}

// BeginTransaction Take Records
func (imit *ImitFirestoreServer) TakeBeginTransactionRecords() []struct {
	P0 context.Context
	P1 *firestore.BeginTransactionRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.BeginTransactionRequest
	}

	// clear records
	imit.lockBeginTransaction.Lock()
	records = imit.records.BeginTransaction
	imit.records.BeginTransaction = nil
	imit.lockBeginTransaction.Unlock()

	return records
}

// BeginTransaction Imitation
func (imit *ImitFirestoreServer) BeginTransaction(P0 context.Context, P1 *firestore.BeginTransactionRequest) (*firestore.BeginTransactionResponse, error) {
	if len(imit.mocks.BeginTransaction) == 0 {
		panic("ImitFirestoreServer.BeginTransaction mocks is nil but ImitFirestoreServer.BeginTransaction was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.BeginTransactionRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockBeginTransaction.Lock()
	// record call
	imit.records.BeginTransaction = append(imit.records.BeginTransaction, call)
	// pop mock
	mockFunc := imit.mocks.BeginTransaction[0]
	imit.mocks.BeginTransaction = imit.mocks.BeginTransaction[1:]
	imit.lockBeginTransaction.Unlock()

	return mockFunc(P0, P1)
}

// Commit Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueCommitMock(m func(P0 context.Context, P1 *firestore.CommitRequest) (*firestore.CommitResponse, error)) {
	imit.lockCommit.Lock()
	imit.mocks.Commit = append(imit.mocks.Commit, m)
	imit.lockCommit.Unlock()
}

// Commit Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueCommitMocks(ms []func(P0 context.Context, P1 *firestore.CommitRequest) (*firestore.CommitResponse, error)) {
	imit.lockCommit.Lock()
	imit.mocks.Commit = append(imit.mocks.Commit, ms...)
	imit.lockCommit.Unlock()
}

// Commit Take Records
func (imit *ImitFirestoreServer) TakeCommitRecords() []struct {
	P0 context.Context
	P1 *firestore.CommitRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.CommitRequest
	}

	// clear records
	imit.lockCommit.Lock()
	records = imit.records.Commit
	imit.records.Commit = nil
	imit.lockCommit.Unlock()

	return records
}

// Commit Imitation
func (imit *ImitFirestoreServer) Commit(P0 context.Context, P1 *firestore.CommitRequest) (*firestore.CommitResponse, error) {
	if len(imit.mocks.Commit) == 0 {
		panic("ImitFirestoreServer.Commit mocks is nil but ImitFirestoreServer.Commit was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.CommitRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockCommit.Lock()
	// record call
	imit.records.Commit = append(imit.records.Commit, call)
	// pop mock
	mockFunc := imit.mocks.Commit[0]
	imit.mocks.Commit = imit.mocks.Commit[1:]
	imit.lockCommit.Unlock()

	return mockFunc(P0, P1)
}

// CreateDocument Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueCreateDocumentMock(m func(P0 context.Context, P1 *firestore.CreateDocumentRequest) (*firestore.Document, error)) {
	imit.lockCreateDocument.Lock()
	imit.mocks.CreateDocument = append(imit.mocks.CreateDocument, m)
	imit.lockCreateDocument.Unlock()
}

// CreateDocument Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueCreateDocumentMocks(ms []func(P0 context.Context, P1 *firestore.CreateDocumentRequest) (*firestore.Document, error)) {
	imit.lockCreateDocument.Lock()
	imit.mocks.CreateDocument = append(imit.mocks.CreateDocument, ms...)
	imit.lockCreateDocument.Unlock()
}

// CreateDocument Take Records
func (imit *ImitFirestoreServer) TakeCreateDocumentRecords() []struct {
	P0 context.Context
	P1 *firestore.CreateDocumentRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.CreateDocumentRequest
	}

	// clear records
	imit.lockCreateDocument.Lock()
	records = imit.records.CreateDocument
	imit.records.CreateDocument = nil
	imit.lockCreateDocument.Unlock()

	return records
}

// CreateDocument Imitation
func (imit *ImitFirestoreServer) CreateDocument(P0 context.Context, P1 *firestore.CreateDocumentRequest) (*firestore.Document, error) {
	if len(imit.mocks.CreateDocument) == 0 {
		panic("ImitFirestoreServer.CreateDocument mocks is nil but ImitFirestoreServer.CreateDocument was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.CreateDocumentRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockCreateDocument.Lock()
	// record call
	imit.records.CreateDocument = append(imit.records.CreateDocument, call)
	// pop mock
	mockFunc := imit.mocks.CreateDocument[0]
	imit.mocks.CreateDocument = imit.mocks.CreateDocument[1:]
	imit.lockCreateDocument.Unlock()

	return mockFunc(P0, P1)
}

// DeleteDocument Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueDeleteDocumentMock(m func(P0 context.Context, P1 *firestore.DeleteDocumentRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteDocument.Lock()
	imit.mocks.DeleteDocument = append(imit.mocks.DeleteDocument, m)
	imit.lockDeleteDocument.Unlock()
}

// DeleteDocument Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueDeleteDocumentMocks(ms []func(P0 context.Context, P1 *firestore.DeleteDocumentRequest) (*emptypb.Empty, error)) {
	imit.lockDeleteDocument.Lock()
	imit.mocks.DeleteDocument = append(imit.mocks.DeleteDocument, ms...)
	imit.lockDeleteDocument.Unlock()
}

// DeleteDocument Take Records
func (imit *ImitFirestoreServer) TakeDeleteDocumentRecords() []struct {
	P0 context.Context
	P1 *firestore.DeleteDocumentRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.DeleteDocumentRequest
	}

	// clear records
	imit.lockDeleteDocument.Lock()
	records = imit.records.DeleteDocument
	imit.records.DeleteDocument = nil
	imit.lockDeleteDocument.Unlock()

	return records
}

// DeleteDocument Imitation
func (imit *ImitFirestoreServer) DeleteDocument(P0 context.Context, P1 *firestore.DeleteDocumentRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.DeleteDocument) == 0 {
		panic("ImitFirestoreServer.DeleteDocument mocks is nil but ImitFirestoreServer.DeleteDocument was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.DeleteDocumentRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockDeleteDocument.Lock()
	// record call
	imit.records.DeleteDocument = append(imit.records.DeleteDocument, call)
	// pop mock
	mockFunc := imit.mocks.DeleteDocument[0]
	imit.mocks.DeleteDocument = imit.mocks.DeleteDocument[1:]
	imit.lockDeleteDocument.Unlock()

	return mockFunc(P0, P1)
}

// GetDocument Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueGetDocumentMock(m func(P0 context.Context, P1 *firestore.GetDocumentRequest) (*firestore.Document, error)) {
	imit.lockGetDocument.Lock()
	imit.mocks.GetDocument = append(imit.mocks.GetDocument, m)
	imit.lockGetDocument.Unlock()
}

// GetDocument Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueGetDocumentMocks(ms []func(P0 context.Context, P1 *firestore.GetDocumentRequest) (*firestore.Document, error)) {
	imit.lockGetDocument.Lock()
	imit.mocks.GetDocument = append(imit.mocks.GetDocument, ms...)
	imit.lockGetDocument.Unlock()
}

// GetDocument Take Records
func (imit *ImitFirestoreServer) TakeGetDocumentRecords() []struct {
	P0 context.Context
	P1 *firestore.GetDocumentRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.GetDocumentRequest
	}

	// clear records
	imit.lockGetDocument.Lock()
	records = imit.records.GetDocument
	imit.records.GetDocument = nil
	imit.lockGetDocument.Unlock()

	return records
}

// GetDocument Imitation
func (imit *ImitFirestoreServer) GetDocument(P0 context.Context, P1 *firestore.GetDocumentRequest) (*firestore.Document, error) {
	if len(imit.mocks.GetDocument) == 0 {
		panic("ImitFirestoreServer.GetDocument mocks is nil but ImitFirestoreServer.GetDocument was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.GetDocumentRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockGetDocument.Lock()
	// record call
	imit.records.GetDocument = append(imit.records.GetDocument, call)
	// pop mock
	mockFunc := imit.mocks.GetDocument[0]
	imit.mocks.GetDocument = imit.mocks.GetDocument[1:]
	imit.lockGetDocument.Unlock()

	return mockFunc(P0, P1)
}

// ListCollectionIds Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueListCollectionIdsMock(m func(P0 context.Context, P1 *firestore.ListCollectionIdsRequest) (*firestore.ListCollectionIdsResponse, error)) {
	imit.lockListCollectionIds.Lock()
	imit.mocks.ListCollectionIds = append(imit.mocks.ListCollectionIds, m)
	imit.lockListCollectionIds.Unlock()
}

// ListCollectionIds Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueListCollectionIdsMocks(ms []func(P0 context.Context, P1 *firestore.ListCollectionIdsRequest) (*firestore.ListCollectionIdsResponse, error)) {
	imit.lockListCollectionIds.Lock()
	imit.mocks.ListCollectionIds = append(imit.mocks.ListCollectionIds, ms...)
	imit.lockListCollectionIds.Unlock()
}

// ListCollectionIds Take Records
func (imit *ImitFirestoreServer) TakeListCollectionIdsRecords() []struct {
	P0 context.Context
	P1 *firestore.ListCollectionIdsRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.ListCollectionIdsRequest
	}

	// clear records
	imit.lockListCollectionIds.Lock()
	records = imit.records.ListCollectionIds
	imit.records.ListCollectionIds = nil
	imit.lockListCollectionIds.Unlock()

	return records
}

// ListCollectionIds Imitation
func (imit *ImitFirestoreServer) ListCollectionIds(P0 context.Context, P1 *firestore.ListCollectionIdsRequest) (*firestore.ListCollectionIdsResponse, error) {
	if len(imit.mocks.ListCollectionIds) == 0 {
		panic("ImitFirestoreServer.ListCollectionIds mocks is nil but ImitFirestoreServer.ListCollectionIds was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.ListCollectionIdsRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListCollectionIds.Lock()
	// record call
	imit.records.ListCollectionIds = append(imit.records.ListCollectionIds, call)
	// pop mock
	mockFunc := imit.mocks.ListCollectionIds[0]
	imit.mocks.ListCollectionIds = imit.mocks.ListCollectionIds[1:]
	imit.lockListCollectionIds.Unlock()

	return mockFunc(P0, P1)
}

// ListDocuments Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueListDocumentsMock(m func(P0 context.Context, P1 *firestore.ListDocumentsRequest) (*firestore.ListDocumentsResponse, error)) {
	imit.lockListDocuments.Lock()
	imit.mocks.ListDocuments = append(imit.mocks.ListDocuments, m)
	imit.lockListDocuments.Unlock()
}

// ListDocuments Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueListDocumentsMocks(ms []func(P0 context.Context, P1 *firestore.ListDocumentsRequest) (*firestore.ListDocumentsResponse, error)) {
	imit.lockListDocuments.Lock()
	imit.mocks.ListDocuments = append(imit.mocks.ListDocuments, ms...)
	imit.lockListDocuments.Unlock()
}

// ListDocuments Take Records
func (imit *ImitFirestoreServer) TakeListDocumentsRecords() []struct {
	P0 context.Context
	P1 *firestore.ListDocumentsRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.ListDocumentsRequest
	}

	// clear records
	imit.lockListDocuments.Lock()
	records = imit.records.ListDocuments
	imit.records.ListDocuments = nil
	imit.lockListDocuments.Unlock()

	return records
}

// ListDocuments Imitation
func (imit *ImitFirestoreServer) ListDocuments(P0 context.Context, P1 *firestore.ListDocumentsRequest) (*firestore.ListDocumentsResponse, error) {
	if len(imit.mocks.ListDocuments) == 0 {
		panic("ImitFirestoreServer.ListDocuments mocks is nil but ImitFirestoreServer.ListDocuments was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.ListDocumentsRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockListDocuments.Lock()
	// record call
	imit.records.ListDocuments = append(imit.records.ListDocuments, call)
	// pop mock
	mockFunc := imit.mocks.ListDocuments[0]
	imit.mocks.ListDocuments = imit.mocks.ListDocuments[1:]
	imit.lockListDocuments.Unlock()

	return mockFunc(P0, P1)
}

// Listen Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueListenMock(m func(P0 firestore.Firestore_ListenServer) error) {
	imit.lockListen.Lock()
	imit.mocks.Listen = append(imit.mocks.Listen, m)
	imit.lockListen.Unlock()
}

// Listen Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueListenMocks(ms []func(P0 firestore.Firestore_ListenServer) error) {
	imit.lockListen.Lock()
	imit.mocks.Listen = append(imit.mocks.Listen, ms...)
	imit.lockListen.Unlock()
}

// Listen Take Records
func (imit *ImitFirestoreServer) TakeListenRecords() []struct {
	P0 firestore.Firestore_ListenServer
} {
	var records []struct {
		P0 firestore.Firestore_ListenServer
	}

	// clear records
	imit.lockListen.Lock()
	records = imit.records.Listen
	imit.records.Listen = nil
	imit.lockListen.Unlock()

	return records
}

// Listen Imitation
func (imit *ImitFirestoreServer) Listen(P0 firestore.Firestore_ListenServer) error {
	if len(imit.mocks.Listen) == 0 {
		panic("ImitFirestoreServer.Listen mocks is nil but ImitFirestoreServer.Listen was just called")
	}

	call := struct {
		P0 firestore.Firestore_ListenServer
	}{
		P0: P0,
	}

	imit.lockListen.Lock()
	// record call
	imit.records.Listen = append(imit.records.Listen, call)
	// pop mock
	mockFunc := imit.mocks.Listen[0]
	imit.mocks.Listen = imit.mocks.Listen[1:]
	imit.lockListen.Unlock()

	return mockFunc(P0)
}

// PartitionQuery Enqueue Mock
func (imit *ImitFirestoreServer) EnqueuePartitionQueryMock(m func(P0 context.Context, P1 *firestore.PartitionQueryRequest) (*firestore.PartitionQueryResponse, error)) {
	imit.lockPartitionQuery.Lock()
	imit.mocks.PartitionQuery = append(imit.mocks.PartitionQuery, m)
	imit.lockPartitionQuery.Unlock()
}

// PartitionQuery Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueuePartitionQueryMocks(ms []func(P0 context.Context, P1 *firestore.PartitionQueryRequest) (*firestore.PartitionQueryResponse, error)) {
	imit.lockPartitionQuery.Lock()
	imit.mocks.PartitionQuery = append(imit.mocks.PartitionQuery, ms...)
	imit.lockPartitionQuery.Unlock()
}

// PartitionQuery Take Records
func (imit *ImitFirestoreServer) TakePartitionQueryRecords() []struct {
	P0 context.Context
	P1 *firestore.PartitionQueryRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.PartitionQueryRequest
	}

	// clear records
	imit.lockPartitionQuery.Lock()
	records = imit.records.PartitionQuery
	imit.records.PartitionQuery = nil
	imit.lockPartitionQuery.Unlock()

	return records
}

// PartitionQuery Imitation
func (imit *ImitFirestoreServer) PartitionQuery(P0 context.Context, P1 *firestore.PartitionQueryRequest) (*firestore.PartitionQueryResponse, error) {
	if len(imit.mocks.PartitionQuery) == 0 {
		panic("ImitFirestoreServer.PartitionQuery mocks is nil but ImitFirestoreServer.PartitionQuery was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.PartitionQueryRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockPartitionQuery.Lock()
	// record call
	imit.records.PartitionQuery = append(imit.records.PartitionQuery, call)
	// pop mock
	mockFunc := imit.mocks.PartitionQuery[0]
	imit.mocks.PartitionQuery = imit.mocks.PartitionQuery[1:]
	imit.lockPartitionQuery.Unlock()

	return mockFunc(P0, P1)
}

// Rollback Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueRollbackMock(m func(P0 context.Context, P1 *firestore.RollbackRequest) (*emptypb.Empty, error)) {
	imit.lockRollback.Lock()
	imit.mocks.Rollback = append(imit.mocks.Rollback, m)
	imit.lockRollback.Unlock()
}

// Rollback Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueRollbackMocks(ms []func(P0 context.Context, P1 *firestore.RollbackRequest) (*emptypb.Empty, error)) {
	imit.lockRollback.Lock()
	imit.mocks.Rollback = append(imit.mocks.Rollback, ms...)
	imit.lockRollback.Unlock()
}

// Rollback Take Records
func (imit *ImitFirestoreServer) TakeRollbackRecords() []struct {
	P0 context.Context
	P1 *firestore.RollbackRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.RollbackRequest
	}

	// clear records
	imit.lockRollback.Lock()
	records = imit.records.Rollback
	imit.records.Rollback = nil
	imit.lockRollback.Unlock()

	return records
}

// Rollback Imitation
func (imit *ImitFirestoreServer) Rollback(P0 context.Context, P1 *firestore.RollbackRequest) (*emptypb.Empty, error) {
	if len(imit.mocks.Rollback) == 0 {
		panic("ImitFirestoreServer.Rollback mocks is nil but ImitFirestoreServer.Rollback was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.RollbackRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockRollback.Lock()
	// record call
	imit.records.Rollback = append(imit.records.Rollback, call)
	// pop mock
	mockFunc := imit.mocks.Rollback[0]
	imit.mocks.Rollback = imit.mocks.Rollback[1:]
	imit.lockRollback.Unlock()

	return mockFunc(P0, P1)
}

// RunQuery Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueRunQueryMock(m func(P0 *firestore.RunQueryRequest, P1 firestore.Firestore_RunQueryServer) error) {
	imit.lockRunQuery.Lock()
	imit.mocks.RunQuery = append(imit.mocks.RunQuery, m)
	imit.lockRunQuery.Unlock()
}

// RunQuery Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueRunQueryMocks(ms []func(P0 *firestore.RunQueryRequest, P1 firestore.Firestore_RunQueryServer) error) {
	imit.lockRunQuery.Lock()
	imit.mocks.RunQuery = append(imit.mocks.RunQuery, ms...)
	imit.lockRunQuery.Unlock()
}

// RunQuery Take Records
func (imit *ImitFirestoreServer) TakeRunQueryRecords() []struct {
	P0 *firestore.RunQueryRequest
	P1 firestore.Firestore_RunQueryServer
} {
	var records []struct {
		P0 *firestore.RunQueryRequest
		P1 firestore.Firestore_RunQueryServer
	}

	// clear records
	imit.lockRunQuery.Lock()
	records = imit.records.RunQuery
	imit.records.RunQuery = nil
	imit.lockRunQuery.Unlock()

	return records
}

// RunQuery Imitation
func (imit *ImitFirestoreServer) RunQuery(P0 *firestore.RunQueryRequest, P1 firestore.Firestore_RunQueryServer) error {
	if len(imit.mocks.RunQuery) == 0 {
		panic("ImitFirestoreServer.RunQuery mocks is nil but ImitFirestoreServer.RunQuery was just called")
	}

	call := struct {
		P0 *firestore.RunQueryRequest
		P1 firestore.Firestore_RunQueryServer
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockRunQuery.Lock()
	// record call
	imit.records.RunQuery = append(imit.records.RunQuery, call)
	// pop mock
	mockFunc := imit.mocks.RunQuery[0]
	imit.mocks.RunQuery = imit.mocks.RunQuery[1:]
	imit.lockRunQuery.Unlock()

	return mockFunc(P0, P1)
}

// UpdateDocument Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueUpdateDocumentMock(m func(P0 context.Context, P1 *firestore.UpdateDocumentRequest) (*firestore.Document, error)) {
	imit.lockUpdateDocument.Lock()
	imit.mocks.UpdateDocument = append(imit.mocks.UpdateDocument, m)
	imit.lockUpdateDocument.Unlock()
}

// UpdateDocument Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueUpdateDocumentMocks(ms []func(P0 context.Context, P1 *firestore.UpdateDocumentRequest) (*firestore.Document, error)) {
	imit.lockUpdateDocument.Lock()
	imit.mocks.UpdateDocument = append(imit.mocks.UpdateDocument, ms...)
	imit.lockUpdateDocument.Unlock()
}

// UpdateDocument Take Records
func (imit *ImitFirestoreServer) TakeUpdateDocumentRecords() []struct {
	P0 context.Context
	P1 *firestore.UpdateDocumentRequest
} {
	var records []struct {
		P0 context.Context
		P1 *firestore.UpdateDocumentRequest
	}

	// clear records
	imit.lockUpdateDocument.Lock()
	records = imit.records.UpdateDocument
	imit.records.UpdateDocument = nil
	imit.lockUpdateDocument.Unlock()

	return records
}

// UpdateDocument Imitation
func (imit *ImitFirestoreServer) UpdateDocument(P0 context.Context, P1 *firestore.UpdateDocumentRequest) (*firestore.Document, error) {
	if len(imit.mocks.UpdateDocument) == 0 {
		panic("ImitFirestoreServer.UpdateDocument mocks is nil but ImitFirestoreServer.UpdateDocument was just called")
	}

	call := struct {
		P0 context.Context
		P1 *firestore.UpdateDocumentRequest
	}{
		P0: P0,
		P1: P1,
	}

	imit.lockUpdateDocument.Lock()
	// record call
	imit.records.UpdateDocument = append(imit.records.UpdateDocument, call)
	// pop mock
	mockFunc := imit.mocks.UpdateDocument[0]
	imit.mocks.UpdateDocument = imit.mocks.UpdateDocument[1:]
	imit.lockUpdateDocument.Unlock()

	return mockFunc(P0, P1)
}

// Write Enqueue Mock
func (imit *ImitFirestoreServer) EnqueueWriteMock(m func(P0 firestore.Firestore_WriteServer) error) {
	imit.lockWrite.Lock()
	imit.mocks.Write = append(imit.mocks.Write, m)
	imit.lockWrite.Unlock()
}

// Write Enqueue Mocks
func (imit *ImitFirestoreServer) EnqueueWriteMocks(ms []func(P0 firestore.Firestore_WriteServer) error) {
	imit.lockWrite.Lock()
	imit.mocks.Write = append(imit.mocks.Write, ms...)
	imit.lockWrite.Unlock()
}

// Write Take Records
func (imit *ImitFirestoreServer) TakeWriteRecords() []struct {
	P0 firestore.Firestore_WriteServer
} {
	var records []struct {
		P0 firestore.Firestore_WriteServer
	}

	// clear records
	imit.lockWrite.Lock()
	records = imit.records.Write
	imit.records.Write = nil
	imit.lockWrite.Unlock()

	return records
}

// Write Imitation
func (imit *ImitFirestoreServer) Write(P0 firestore.Firestore_WriteServer) error {
	if len(imit.mocks.Write) == 0 {
		panic("ImitFirestoreServer.Write mocks is nil but ImitFirestoreServer.Write was just called")
	}

	call := struct {
		P0 firestore.Firestore_WriteServer
	}{
		P0: P0,
	}

	imit.lockWrite.Lock()
	// record call
	imit.records.Write = append(imit.records.Write, call)
	// pop mock
	mockFunc := imit.mocks.Write[0]
	imit.mocks.Write = imit.mocks.Write[1:]
	imit.lockWrite.Unlock()

	return mockFunc(P0)
}
